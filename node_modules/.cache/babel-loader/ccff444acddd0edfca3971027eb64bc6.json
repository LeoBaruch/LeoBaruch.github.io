{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\n\nconst _hoisted_1 = /*#__PURE__*/_createStaticVNode(\"<html><head></head><body><h2>2-3树</h2><p>上文说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为<strong>N</strong>,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了<strong>2-3树</strong>概念</p><h3>定义</h3><p>为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成:</p><ul><li><p>2-节点: 标准的二叉查找树中的节点.含有<strong>一个键</strong>（及其对应的值）和<strong>两条链接</strong>,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。</p></li><li><p>3-节点: 含有<strong>两个键</strong>（及其对应的值）和<strong>三条链接</strong>，<strong>左链接</strong>指向的 目标节点的键都<strong>小于</strong>该结点，中链接指向的 目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。</p></li></ul><h3>查找</h3><p>将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中</p><p><img src=\\\"assets/2-3%E6%A0%91%E6%9F%A5%E6%89%BE.png\\\" alt=\\\"2-3树查找的命中与未命中\\\"></p><h3>插入</h3><p>空树的插入很简单,创建一个节点即可.非空树则分四种情况:</p><ul><li><p>向2-节点中插入元素；</p></li><li><p>向一颗只含有一个3-节点的树中插入元素；</p></li><li><p>向一个父节点为2-节点的3-节点中插入元素；</p></li><li><p>向一个父节点为3-节点的3-节点中插入元素</p></li></ul><h4>向2-节点中插入元素</h4><p>如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点</p><p><img src=\\\"assets/%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E9%94%AE.png\\\" alt=\\\"向2-结点中插入新的键\\\"></p><h4>向一颗只含有一个3-节点的树中插入元素</h4><p>我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树</p><p><img src=\\\"assets/%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%AA%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AA3-%E7%BB%93%E7%82%B9%E7%9A%84%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE.png\\\" alt=\\\"向一棵只含有一个 3- 结点的树中插入新键\\\"></p><h4>向一个父节点为2-节点的3-节点中插入元素</h4><p>我们先像刚才一样构造一个临时的 4- 结点并将其分解, 但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中, 父结点是一个 2- 结点（一个键两条链接）， 插入之后变为了一个 3- 结点. 这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的， 插入后所有的空链接到根结点的距离仍然相同</p><p><img src=\\\"assets/%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA2-%E8%8A%82%E7%82%B9%E7%9A%843-%E8%8A%82%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png\\\" alt=\\\"向一个父节点为2-节点的3-节点中插入元素\\\"></p><h4>向一个父节点为3-节点的3-节点中插入元素</h4><p>再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点， 然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况， 我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根</p><p><img src=\\\"assets/\\\" alt=\\\"\\\"></p><p>分解根节点</p><p><img src=\\\"assets/\\\" alt=\\\"\\\"></p><h3>性质:</h3><p>和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的</p><blockquote><p><strong>命题 F</strong>在一棵大小为 的 2-3 树中，查找和插入操作访问的结点必然不超过<strong>lgN</strong></p></blockquote><blockquote><p><strong>证明</strong>。一棵含有 N 个结点的 2-3 树的高度在 <strong>log3 N</strong>（如果树中全是 3- 结点）和 <strong>log2 N</strong>（如果树中全是 2- 结点）之间</p></blockquote></body></html>\", 1);\n\nconst _hoisted_2 = [_hoisted_1];\nexport function render(_ctx, _cache) {\n  return _openBlock(), _createElementBlock(\"section\", null, _hoisted_2);\n}","map":{"version":3,"mappings":";;gCAAAA;;oBAASC;;uBAATC,oBAyDwB,SAzDxB,EAyDwB,IAzDxB","names":["_createStaticVNode","_hoisted_1","_createElementBlock"],"sourceRoot":"","sources":["/Users/gexiaolong/Downloads/others/coding/myblog/src/md/2-3tree.md"],"sourcesContent":["<template><section><html><head></head><body><h2>2-3树</h2>\n<p>上文说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为<strong>N</strong>,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了<strong>2-3树</strong>概念</p>\n<h3>定义</h3>\n<p>为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成:</p>\n<ul>\n<li>\n<p>2-节点: 标准的二叉查找树中的节点.含有<strong>一个键</strong>（及其对应的值）和<strong>两条链接</strong>,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。</p>\n</li>\n<li>\n<p>3-节点: 含有<strong>两个键</strong>（及其对应的值）和<strong>三条链接</strong>，<strong>左链接</strong>指向的 目标节点的键都<strong>小于</strong>该结点，中链接指向的 目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。</p>\n</li>\n</ul>\n<h3>查找</h3>\n<p>将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中</p>\n<p><img src=\"assets/2-3%E6%A0%91%E6%9F%A5%E6%89%BE.png\" alt=\"2-3树查找的命中与未命中\"></p>\n<h3>插入</h3>\n<p>空树的插入很简单,创建一个节点即可.非空树则分四种情况:</p>\n<ul>\n<li>\n<p>向2-节点中插入元素；</p>\n</li>\n<li>\n<p>向一颗只含有一个3-节点的树中插入元素；</p>\n</li>\n<li>\n<p>向一个父节点为2-节点的3-节点中插入元素；</p>\n</li>\n<li>\n<p>向一个父节点为3-节点的3-节点中插入元素</p>\n</li>\n</ul>\n<h4>向2-节点中插入元素</h4>\n<p>如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点</p>\n<p><img src=\"assets/%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E9%94%AE.png\" alt=\"向2-结点中插入新的键\"></p>\n<h4>向一颗只含有一个3-节点的树中插入元素</h4>\n<p>我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树</p>\n<p><img src=\"assets/%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%AA%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AA3-%E7%BB%93%E7%82%B9%E7%9A%84%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE.png\" alt=\"向一棵只含有一个 3- 结点的树中插入新键\"></p>\n<h4>向一个父节点为2-节点的3-节点中插入元素</h4>\n<p>我们先像刚才一样构造一个临时的 4- 结点并将其分解, 但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中, 父结点是一个 2- 结点（一个键两条链接），\n插入之后变为了一个 3- 结点. 这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，\n插入后所有的空链接到根结点的距离仍然相同</p>\n<p><img src=\"assets/%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA2-%E8%8A%82%E7%82%B9%E7%9A%843-%E8%8A%82%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png\" alt=\"向一个父节点为2-节点的3-节点中插入元素\"></p>\n<h4>向一个父节点为3-节点的3-节点中插入元素</h4>\n<p>再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点，\n然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，\n我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根</p>\n<p><img src=\"assets/\" alt=\"\"></p>\n<p>分解根节点</p>\n<p><img src=\"assets/\" alt=\"\"></p>\n<h3>性质:</h3>\n<p>和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的</p>\n<blockquote>\n<p><strong>命题 F</strong>在一棵大小为  的 2-3 树中，查找和插入操作访问的结点必然不超过<strong>lgN</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>证明</strong>。一棵含有 N 个结点的 2-3 树的高度在 <strong>log3 N</strong>（如果树中全是 3- 结点）和 <strong>log2 N</strong>（如果树中全是 2- 结点）之间</p>\n</blockquote>\n</body></html></section></template>\n\n"]},"metadata":{},"sourceType":"module"}