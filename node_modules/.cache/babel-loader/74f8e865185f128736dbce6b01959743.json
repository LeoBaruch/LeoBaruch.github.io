{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode(\"html\", null, [/*#__PURE__*/_createElementVNode(\"head\"), /*#__PURE__*/_createElementVNode(\"body\", null, [/*#__PURE__*/_createElementVNode(\"h2\", null, \"红黑树二叉搜索树\"), /*#__PURE__*/_createElementVNode(\"p\", null, [/*#__PURE__*/_createTextVNode(\"上文中2-3树可以实现树的\"), /*#__PURE__*/_createElementVNode(\"strong\", null, \"有序性\"), /*#__PURE__*/_createTextVNode(\"与\"), /*#__PURE__*/_createElementVNode(\"strong\", null, \"平衡性\"), /*#__PURE__*/_createTextVNode(\",但是要维护两种不同类型的节点,将被查找的键和结点中的每个键 进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到 另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会 使算法比标准的二叉查找树更慢.\")])])], -1\n/* HOISTED */\n);\n\nconst _hoisted_2 = [_hoisted_1];\nexport function render(_ctx, _cache) {\n  return _openBlock(), _createElementBlock(\"section\", null, _hoisted_2);\n}","map":{"version":3,"mappings":";;gCAASA,oBAKK,MALL,EAKK,IALL,EAKK,cALCA,oBAAa,MAAb,CAKD,eALcA,oBAKrB,MALqB,EAKrB,IALqB,EAKrB,cAL2BA,oBAAiB,IAAjB,EAAiB,IAAjB,EAAI,UAAJ,CAK3B,eAJPA,oBAGmB,GAHnB,EAGmB,IAHnB,EAGmB,cAJnBC,iBACG,eADH,CAImB,eAHHD,oBAAoB,QAApB,EAAoB,IAApB,EAAQ,KAAR,CAGG,eAJnBC,iBACoC,GADpC,CAImB,eAHkBD,oBAAoB,QAApB,EAAoB,IAApB,EAAQ,KAAR,CAGlB,eAJnBC,iBACyD,kIADzD,CAImB,CAHnB,CAIO,CALqB,CAKd,CALL;;AAAA;;oBAAAC;;uBAATC,oBAKwB,SALxB,EAKwB,IALxB","names":["_createElementVNode","_createTextVNode","_hoisted_1","_createElementBlock"],"sourceRoot":"","sources":["/Users/gexiaolong/Downloads/others/coding/myblog/src/md/redBlackBST.md"],"sourcesContent":["<template><section><html><head></head><body><h2>红黑树二叉搜索树</h2>\n<p>上文中2-3树可以实现树的<strong>有序性</strong>与<strong>平衡性</strong>,但是要维护两种不同类型的节点,将被查找的键和结点中的每个键\n进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到\n另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会\n使算法比标准的二叉查找树更慢.</p>\n</body></html></section></template>\n\n"]},"metadata":{},"sourceType":"module"}