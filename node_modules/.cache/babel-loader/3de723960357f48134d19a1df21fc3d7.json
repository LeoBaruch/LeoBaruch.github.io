{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\n\nconst _hoisted_1 = /*#__PURE__*/_createStaticVNode(\"<html><head></head><body><h2>2-3树</h2><p>上文说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为<strong>N</strong>,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了<strong>2-3树</strong>概念</p><h3>定义</h3><p>为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成:</p><ul><li><p>2-节点: 标准的二叉查找树中的节点.含有<strong>一个键</strong>（及其对应的值）和<strong>两条链接</strong>,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。</p></li><li><p>3-节点: 含有<strong>两个键</strong>（及其对应的值）和<strong>三条链接</strong>，<strong>左链接</strong>指向的 目标节点的键都<strong>小于</strong>该结点，中链接指向的 目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。</p></li></ul><h3>查找</h3><p>将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中</p><p><img src=\\\"assets/2-3%E6%A0%91%E6%9F%A5%E6%89%BE.png\\\" alt=\\\"2-3树查找的命中与未命中\\\"></p><h3>插入</h3><p>空树的插入很简单,创建一个节点即可.非空树则分四种情况:</p><ul><li><p>向2-节点中插入元素；</p></li><li><p>向一颗只含有一个3-节点的树中插入元素；</p></li><li><p>向一个父节点为2-节点的3-节点中插入元素；</p></li><li><p>向一个父节点为3-节点的3-节点中插入元素</p></li></ul><h4>向2-节点中插入元素</h4><p>如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点</p><p><img src=\\\"assets/%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E9%94%AE.png\\\" alt=\\\"向2-结点中插入新的键\\\"></p><h4>向一颗只含有一个3-节点的树中插入元素</h4><p>我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树</p><p>![向一棵只含有一个 3- 结点的树中插入新键](assets/向一棵只含有一个 3- 结点的树中插入新键.png)</p></body></html>\", 1);\n\nconst _hoisted_2 = [_hoisted_1];\nexport function render(_ctx, _cache) {\n  return _openBlock(), _createElementBlock(\"section\", null, _hoisted_2);\n}","map":{"version":3,"mappings":";;gCAAAA;;oBAASC;;uBAATC,oBAqCwB,SArCxB,EAqCwB,IArCxB","names":["_createStaticVNode","_hoisted_1","_createElementBlock"],"sourceRoot":"","sources":["/Users/gexiaolong/Downloads/others/coding/myblog/src/md/2-3tree.md"],"sourcesContent":["<template><section><html><head></head><body><h2>2-3树</h2>\n<p>上文说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为<strong>N</strong>,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了<strong>2-3树</strong>概念</p>\n<h3>定义</h3>\n<p>为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成:</p>\n<ul>\n<li>\n<p>2-节点: 标准的二叉查找树中的节点.含有<strong>一个键</strong>（及其对应的值）和<strong>两条链接</strong>,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。</p>\n</li>\n<li>\n<p>3-节点: 含有<strong>两个键</strong>（及其对应的值）和<strong>三条链接</strong>，<strong>左链接</strong>指向的 目标节点的键都<strong>小于</strong>该结点，中链接指向的 目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。</p>\n</li>\n</ul>\n<h3>查找</h3>\n<p>将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中</p>\n<p><img src=\"assets/2-3%E6%A0%91%E6%9F%A5%E6%89%BE.png\" alt=\"2-3树查找的命中与未命中\"></p>\n<h3>插入</h3>\n<p>空树的插入很简单,创建一个节点即可.非空树则分四种情况:</p>\n<ul>\n<li>\n<p>向2-节点中插入元素；</p>\n</li>\n<li>\n<p>向一颗只含有一个3-节点的树中插入元素；</p>\n</li>\n<li>\n<p>向一个父节点为2-节点的3-节点中插入元素；</p>\n</li>\n<li>\n<p>向一个父节点为3-节点的3-节点中插入元素</p>\n</li>\n</ul>\n<h4>向2-节点中插入元素</h4>\n<p>如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点</p>\n<p><img src=\"assets/%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E9%94%AE.png\" alt=\"向2-结点中插入新的键\"></p>\n<h4>向一颗只含有一个3-节点的树中插入元素</h4>\n<p>我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树</p>\n<p>![向一棵只含有一个 3- 结点的树中插入新键](assets/向一棵只含有一个 3- 结点的树中插入新键.png)</p>\n</body></html></section></template>\n\n"]},"metadata":{},"sourceType":"module"}