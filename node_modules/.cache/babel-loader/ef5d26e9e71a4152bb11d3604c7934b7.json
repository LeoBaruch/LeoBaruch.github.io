{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\n\nconst _hoisted_1 = /*#__PURE__*/_createStaticVNode(\"<html><head></head><body><h2>优先队列 (算法第四版2.4)</h2><p>普通队列是一种先进先出的数据结构，先放进队列的元素取值时优先被取出来。而优先队列是一种具有最高优先级元素先出的数据结构，比如每次取值都取最大的元素, 它包含最重要的两种操作: 删除最大元素delMax和插入元素insert().</p><h3>堆的定义</h3><p>当一颗二叉树的每个节点都大于等于它的两个子节点时,它被称为堆有序, 所以根节点是堆有序的二叉树中的最大节点</p><h3>二叉堆表示法</h3><h4>完全二叉树的定义</h4><p>二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）</p><h4>数组表示完全二叉树</h4><p>如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）. 如果我们使用完全二叉树，表达就会变得特别方便</p><p>完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。 <strong>（不使用数组的第一个位置, 哨兵）</strong></p><p><strong>简单起见，在下文中我们将二叉堆简称为堆）</strong> 在一个堆中，位置 <strong>k</strong> 的结点的父结点的位置为 <strong>k / 2</strong>而它的两个子结点的位置则分别为 <strong>2k</strong> 和 <strong>2k+1</strong>。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1。</p><p><strong>命题 P</strong>。一棵大小为 的完全二叉树的高度为 。</p><p>证明。通过归纳很容易可以证明这一点，且当 达到 2 的幂时树的高度会加 1。</p><h3>堆的算法</h3><p>我们用长度为 <strong>k + 1</strong> 的私有数组 pq[] 来表示一个大小为 <strong>k</strong> 的堆，我们不会使用 pq[0]，堆元素放在 pq[1] 至 pq[N] 中</p></body></html>\", 1);\n\nconst _hoisted_2 = [_hoisted_1];\nexport function render(_ctx, _cache) {\n  return _openBlock(), _createElementBlock(\"section\", null, _hoisted_2);\n}","map":{"version":3,"mappings":";;gCAAAA;;oBAASC;;uBAATC,oBAewB,SAfxB,EAewB,IAfxB","names":["_createStaticVNode","_hoisted_1","_createElementBlock"],"sourceRoot":"","sources":["/Users/gexiaolong/Downloads/others/coding/myblog/src/md/PriorityQueue.md"],"sourcesContent":["<template><section><html><head></head><body><h2>优先队列 (算法第四版2.4)</h2>\n<p>普通队列是一种先进先出的数据结构，先放进队列的元素取值时优先被取出来。而优先队列是一种具有最高优先级元素先出的数据结构，比如每次取值都取最大的元素, 它包含最重要的两种操作: 删除最大元素delMax和插入元素insert().</p>\n<h3>堆的定义</h3>\n<p>当一颗二叉树的每个节点都大于等于它的两个子节点时,它被称为堆有序, 所以根节点是堆有序的二叉树中的最大节点</p>\n<h3>二叉堆表示法</h3>\n<h4>完全二叉树的定义</h4>\n<p>二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）</p>\n<h4>数组表示完全二叉树</h4>\n<p>如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）. 如果我们使用完全二叉树，表达就会变得特别方便</p>\n<p>完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。 <strong>（不使用数组的第一个位置, 哨兵）</strong></p>\n<p><strong>简单起见，在下文中我们将二叉堆简称为堆）</strong> 在一个堆中，位置 <strong>k</strong> 的结点的父结点的位置为 <strong>k / 2</strong>而它的两个子结点的位置则分别为 <strong>2k</strong> 和 <strong>2k+1</strong>。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1。</p>\n<p><strong>命题 P</strong>。一棵大小为  的完全二叉树的高度为 。</p>\n<p>证明。通过归纳很容易可以证明这一点，且当 达到 2 的幂时树的高度会加 1。</p>\n<h3>堆的算法</h3>\n<p>我们用长度为 <strong>k + 1</strong> 的私有数组 pq[] 来表示一个大小为 <strong>k</strong> 的堆，我们不会使用 pq[0]，堆元素放在 pq[1] 至 pq[N] 中</p>\n</body></html></section></template>\n\n"]},"metadata":{},"sourceType":"module"}