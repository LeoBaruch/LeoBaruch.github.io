## 2-3树

上文说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为**N**,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了**2-3树**概念



### 定义

为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成:

- 2-节点: 标准的二叉查找树中的节点.含有**一个键**（及其对应的值）和**两条链接**,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。 

- 3-节点: 含有**两个键**（及其对应的值）和**三条链接**，**左链接**指向的 目标节点的键都**小于**该结点，中链接指向的 目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。


### 查找

将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中

![2-3树查找的命中与未命中](assets/2-3树查找.png)

### 插入

空树的插入很简单,创建一个节点即可.非空树则分四种情况:

- 向2-节点中插入元素；
 
- 向一颗只含有一个3-节点的树中插入元素；
 
- 向一个父节点为2-节点的3-节点中插入元素；
 
- 向一个父节点为3-节点的3-节点中插入元素


#### 向2-节点中插入元素

如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点

![向2-结点中插入新的键](assets/向2-结点中插入新的键.png)

#### 向一颗只含有一个3-节点的树中插入元素

我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树

![向一棵只含有一个 3- 结点的树中插入新键](assets/向一棵只含有一个3-结点的树中插入新键.png)


#### 向一个父节点为2-节点的3-节点中插入元素

我们先像刚才一样构造一个临时的 4- 结点并将其分解, 但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中, 父结点是一个 2- 结点（一个键两条链接），
插入之后变为了一个 3- 结点. 这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，
插入后所有的空链接到根结点的距离仍然相同

![向一个父节点为2-节点的3-节点中插入元素](assets/向一个父节点为2-节点的3-节点中插入元素.png)

#### 向一个父节点为3-节点的3-节点中插入元素

再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点，
然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，
我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根

![向一个父节点为3-节点的3-节点中插入元素](assets/向一个父节点为3-节点的3-节点中插入元素.png)

分解根节点

![向一个父节点为3-节点的3-节点中插入元素-分解跟元素](assets/向一个父节点为3-节点的3-节点中插入元素-分解跟元素.png)

2-3树节点关系

![2-3树节点关系](assets/2-3树节点关系.png)

2-3树构造轨迹, 即使升序插入也不会退化为链表,如下图右所示:

![2-3树构造轨迹](assets/2-3树构造轨迹.png)

### 性质:

和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的

> **命题 F**在一棵大小为  的 2-3 树中，查找和插入操作访问的结点必然不超过**lgN**

> **证明**。一棵含有 N 个结点的 2-3 树的高度在 **log3 N**（如果树中全是 3- 结点）和 **log2 N**（如果树中全是 2- 结点）之间

















