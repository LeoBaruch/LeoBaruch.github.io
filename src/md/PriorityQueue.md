## 优先队列 (算法第四版2.4)

普通队列是一种先进先出的数据结构，先放进队列的元素取值时优先被取出来。而优先队列是一种具有最高优先级元素先出的数据结构，比如每次取值都取最大的元素, 它包含最重要的两种操作: 删除最大元素delMax和插入元素insert().

### 堆的定义

当一颗二叉树的每个节点都大于等于它的两个子节点时,它被称为堆有序, 所以根节点是堆有序的二叉树中的最大节点

### 二叉堆表示法

#### 完全二叉树的定义

二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）

#### 数组表示完全二叉树

如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）. 如果我们使用完全二叉树，表达就会变得特别方便

完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。 **（不使用数组的第一个位置, 哨兵）**

**简单起见，在下文中我们将二叉堆简称为堆）** 在一个堆中，位置 **k** 的结点的父结点的位置为 **k / 2**而它的两个子结点的位置则分别为 **2k** 和 **2k+1**。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1。


> **命题 P**。一棵大小为 **N** 的完全二叉树的高度为 **lgN**。


> **证明**。通过归纳很容易可以证明这一点，且当 达到 2 的幂时树的高度会加 1。

### 堆的算法

我们用长度为 **k + 1** 的私有数组 pq[] 来表示一个大小为 **k** 的堆，我们不会使用 pq[0]，堆元素放在 pq[1] 至 pq[N] 中

#### 堆实现的比较和交换方法

因为所有的元素都在数组 pq[] 中，不再将数组作为参数传递

```java
private boolean less(int i, int j)
{  return pq[i].compareTo(pq[j]) < 0;  }

private void exch(int i, int j)
{  Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;  }

```

#### 由下自上的堆有序化（上浮）

当调用优先队列的insert方法时，我们首先把元素放置到数组的结尾，然后再把该元素上浮到正确的节点，最终形成堆有序状态。

```java
private void swim(int k)
{
   while (k > 1 && less(k/2, k))
   {
      exch(k/2, k);
      k = k/2;
   }
}


```

#### 由上至下的堆有序化（下沉）

```java

private void sink(int k)
{
   while (2*k <= N)
   {
      int j = 2*k;
      if (j < N && less(j, j+1)) j++;
      if (!less(k, j)) break;
      exch(k, j);
      k = j;
   }
}

```

![堆的操作]('../assets/堆的操作.png')


####

```java

public class MaxPQ<Key extends Comparable<Key>>
{
  private Key[] pq;             // 基于堆的完全按二叉树”
  private int N = 0;            // 存储于pq[1..N]中，pq[0]没有使用

   public MaxPQ(int maxN)
   {  pq = (Key[]) new Comparable[maxN+1];  }

   public boolean isEmpty()
   {  return N == 0;  }

   public int size()
   {  return N;  }

   public void insert(Key v)
   {
      pq[++N] = v;
      swim(N);
   }

   public Key delMax()
   {
      Key max = pq[1];           // 从根结点得到最大元素
      exch(1, N--);              // 将其和最后一个结点交换
      pq[N+1] = null;            // 防止对象游离
      sink(1);                   // 恢复堆的有序性
      return max;
   }

   // 辅助方法的实现请见本节前面的代码框
   private boolean less(int i, int j)
   private void exch(int i, int j)
   private void swim(int k)
   private void sink(int k)
}

```

优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。在 insert() 中，我们将 N 加一并把新元素添加在数组最后，然后用 swim() 恢复堆的秩序。在 delMax() 中，我们从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink() 恢复堆的秩序。同时我们还将不再使用的 pq[N+1] 设为 null，以便系统回收它所占用的空间。这里省略了动态调整数组大小的代码


> **命题 Q**。对于一个含有 **N** 个元素的基于堆的优先队列，插入元素操作只需不超过（**lgN + 1**）次比较，删除最大元素的操作需要不超过 **2lgN** 次比较。

> **证明**。由命题 P 可知，两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过 **lgN**。对于路径上的每个结点，删除最大元素需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。












