{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/05/26/hello-world/"},{"title":"mac-tools","text":"Mac各种效率工具 开发 vscode: 编辑器 Charles: 抓包工具 postman: 测试api iTerm2: 终端神器 navicat: 数据库gui 命令行工具 on my zsh: a delightful, open source, community-driven framework for managing your Zsh configuration fasd: Fasd offers quick access to files and directories for POSIX shells. 效率 alfred4 Bartender4: Menubar 菜单栏管理小助手 macdown: markdown VPN: clashX IINA: 视频播放器 Karabiner-Elements: mac键位修改神器 moom 窗口整理、排列、缩放工具 Manico 应用启动和切换工具","link":"/2022/05/26/mac-tools/"},{"title":"commit-message","text":"Commit message 提交标准Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交, 一般来说，commit message 应该清晰明了，说明本次提交的目的 本文介绍的是Angular 规范 commit message的格式包含: Header、Body和Footer 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略,暂时不讲 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）,简短,保持美观 HeaderHeader部分只有一行，包括三个字段： type（必需） scope（可选） subject（必需） typetype用于说明 commit 的类别，只允许使用下面7个标识。 1234567feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subjectsubject是 commit 目的的简短描述，不超过50个字符。 比较规范的提交应该如下:","link":"/2022/05/26/commit-message/"},{"title":"几种查找的数据结构(二叉搜索树、2-3树及红黑树)","text":"现代计算机和网络使我们能够访问海量的信息。高效检索这些信息的能力是处理它们的重要前提.本文主要介绍几种经典的数据结构,及分析其插入和查找效率 链表下图为一个基于单向链表的添加与查找的轨迹.每次插入一个新元素前先查找是否存在相同的key,不存在则在首部新增一个节点,存在则替换当前节点的值. 由上图可知,一个链表长度为N插入一个新数据的时间复杂度为 O(1), 即只需在首部插入即可.而查找,需要每个节点依次寻找,最好为1,最差为N.平均时间复杂度为O(N) 有序数组无序数组与链表类似,查询依次为O(N),添加为O(1); 有序数组的查找分两种: 一种是顺序查找时间复杂度为O(N), 另一种是二分查找时间复杂度是O(logN).添加时间复杂度为O(N), 插入流程如下图: 二叉查找树以上两种数据结构插入和查找的时间复杂度如下表 数据结构 查找 插入 链表 O(N) O(1) 有序数组(顺序查找) O(N) O(N) 有序数组(二分查找) O(log N) O(N) 由上图可以看出不论是链表与数组,他的查找和插入顺序都不是很尽如人意, 若构建一个长度为N的数据,两种存储方式: 链表: 插入次数 为 N * 1, 查询替换为 N * N, 查询速度太慢 数组(二分查找): 插入为 N * N, 查询替换为 NlogN, 插入速度太慢 那有没有一个数据结构能不能兼具查询和插入都足够效率的优点呢.这里我们先介绍下二叉查找树的基本特征.然后再分析 二叉查找树定义一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键. 每一个二叉搜索树的左右子树也都是一个二叉搜索树 二叉搜索树如果用中序遍历一下，就是一个从小到大的递增序列 下图是一颗二叉查找树, 中序遍历得到的结果是 A C E H R S X 二叉查找树查找在二叉查找树中分别查找 R 和 T R: 先找根节点 S, R小于S, 在 S的左子树查找, 左子树根节点 E, R大于 E, 则在E的右子树找, 右子树根节点 R, 命中. T: 先找根节点 S, T小于S, 在 S的右子树查找, 左子树根节点 X, T小于 X, 则在E的右子树找, 左子树根节点为空, 未命中 二叉查找树插入二叉查找树的查找几乎和二分查找的一样简单,而且插入的实现难度和查找差不多,当要插入的节点的键在二叉查找树查找树命中时,则直接替换命中键的值.未被命中为空节点时,如果被查找的键小于空节点根结点的键，我们会继续在左子树中插入该键，否则在右子树中插入该键。 平衡二叉树的2-3树·概念什么是平衡二叉树: 可以是空树。 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。 分析使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一棵含有 N 个结点的树是完全平衡的，每条空链接和根结点的距离都为 logN。在最坏的情况下，搜索路径上可能有 N个结点, 变成了一个链表.如图所示。但在一般情况下树的形状和最好情况更接近。 2-3树上面说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为N,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了2-3树概念 2-3树定义为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成: 2-节点: 标准的二叉查找树中的节点.含有一个键（及其对应的值）和两条链接,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。 3-节点: 含有两个键（及其对应的值）和三条链接，左链接指向的目标节点的键都小于该结点，中链接指向的目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。 注: 一棵完美平衡的 2-3 查找树中的所有空链接到根结点的距离都应该是相同的。简洁起见，这里我们用 2-3 树指代一棵完美平衡的 2-3 查找树（在其他情况下这个词应该表示一种更一般的结构） 2-3树的查找将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中 下图为对H的命中查找及对B的未命中查找: 2-3树插入空树的插入很简单,创建一个节点即可.非空树则分四种情况: 向2-节点中插入元素； 向一颗只含有一个3-节点的树中插入元素； 向一个父节点为2-节点的3-节点中插入元素； 向一个父节点为3-节点的3-节点中插入元素2-3树 向2-节点中插入元素如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点 向一颗只含有一个3-节点的树中插入元素我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树 向一个父节点为2-节点的3-节点中插入元素我们先像刚才一样构造一个临时的 4- 结点并将其分解, 但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中, 父结点是一个 2- 结点（一个键两条链接），插入之后变为了一个 3- 结点. 这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同 向一个父节点为3-节点的3-节点中插入元素再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根,然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树 分解根节点 2-3树节点关系 2-3树构造轨迹: 即使升序插入也不会退化为链表,如下图所示: 性质:和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的 命题 F在一棵大小为 的 2-3 树中，查找和插入操作访问的结点必然不超过lgN 证明。一棵含有 N 个结点的 2-3 树的高度在 log3 N（如果树中全是 3- 结点）和 log2 N（如果树中全是 2- 结点）之间 红黑树二叉搜索树上文中2-3树可以实现树的有序性与平衡性,但是要维护两种不同类型的节点(2-节点与3-节点),将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢. 红黑树二叉搜索树替换2-3树红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由 2- 结点构成）和一些额外的信息（替换 3- 结点）来表示 2-3 树.树的链接分为两种: 红链接将两个 2- 结点连 红黑树二叉搜索树定义红黑树是含有红黑链接并满足下列条件的二叉查找树： 红链接均为左链接； 没有任何一个结点同时和两条红链接相连； 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 满足这样定义的红黑树和相应的 2-3 树是一一对应的 红黑树二叉搜索树的插入每次插入的节点的时候都将节点的颜色初始化为红色 旋转在我们实现的某些操作中(比如插入)可能会出现红色右链接或者两条连续的红链接,需要通过旋转和变换颜色修复,旋转操作会改变红链接的指向, 左旋转 右旋转 无论是rotateRight()或rotateLeft() , 我们总是将其返回值重置父结点（或是根结点),且保留原来父节点的颜色(将 x.color 设为 h.color) 颜色变换当我们的节点经过左右旋转时,有可能出现左右节点均为红色的场景,此时,我们需要颜色变换. 我们专门用一个方法 flipColors() 来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将父结点的颜色由黑变红(相当于父节点上浮,和它的父节点结合成为一个3-节点),这项操作和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性. 红黑树的链接向上传递只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作, 在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果右子结点是红色的而左子结点是黑色的，进行左旋转； 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转； 如果左右子结点均为红色，进行颜色转换。 注意,红黑树的根节点为黑色! 复合的插入过程 完整得建立一颗红黑树","link":"/2022/06/12/search/"},{"title":"webpack-cli 源码解析(上)","text":"文中所引用的源码版本: webpack@4.46.0 webpack 命令当我们在项目中的package.json中的字段“scripts”对象配置属性: “build”: “webpack entry.js bundle.js” . 然后npm run build会发生什么呢? 首先npm会让命令行工具进入node_modules/.bin目录中查询是否存在“webpack“命令,若存在则执行,没找到则报错.实际命令的入口文件是“webpack”这个npm包的package.json中bin字段的文件路径, 即 node_modules/webpack/bin/webpack.js. 1&quot;bin&quot;: &quot;./bin/webpack.js&quot;, 分析 /bin/webpack.js源码大致流程是,判断是否安装了命令行工具webpack-cli(或者webpack-command, 默认webpack-cli), 若没有安装,则提示安装webpack-cli, 若安装了其中一个,则引用(执行) 若两个命令行工具都安装了,则提示卸载其中一个或者直接执行他们自己的命令(webpack-cli xx xx). 原文: please remove one of them or use them directly via their binary. 判断命令行是否安装逻辑12345678910111213141516171819202122232425262728293031323334353637// 使用node内部的 require() 工具查找模块的位置，但不加载模块，只返回解析的文件名。// 如果找不到模块，则会抛出 MODULE_NOT_FOUND 错误。const isInstalled = packageName =&gt; { try { require.resolve(packageName); return true; } catch (err) { return false; }};const CLIs = [ { name: &quot;webpack-cli&quot;, package: &quot;webpack-cli&quot;, binName: &quot;webpack-cli&quot;, alias: &quot;cli&quot;, installed: isInstalled(&quot;webpack-cli&quot;), recommended: true, url: &quot;https://github.com/webpack/webpack-cli&quot;, description: &quot;The original webpack full-featured CLI.&quot; }, { name: &quot;webpack-command&quot;, package: &quot;webpack-command&quot;, binName: &quot;webpack-command&quot;, alias: &quot;command&quot;, installed: isInstalled(&quot;webpack-command&quot;), recommended: false, url: &quot;https://github.com/webpack-contrib/webpack-command&quot;, description: &quot;A lightweight, opinionated webpack CLI.&quot; }];const installedClis = CLIs.filter(cli =&gt; cli.installed); 没有安装命令行当上面代码中的installedClis.length === 0时,即没有安装任何命令行工具,则提示安装webpack-cli 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 const runCommand = (command, args) =&gt; { const cp = require(&quot;child_process&quot;); return new Promise((resolve, reject) =&gt; { const executedCommand = cp.spawn(command, args, { stdio: &quot;inherit&quot;, shell: true }); executedCommand.on(&quot;error&quot;, error =&gt; { reject(error); }); executedCommand.on(&quot;exit&quot;, code =&gt; { if (code === 0) { resolve(); } else { reject(); } }); }); }; // 判断是否使用yarn安装包const isYarn = fs.existsSync(path.resolve(process.cwd(), &quot;yarn.lock&quot;));const packageManager = isYarn ? &quot;yarn&quot; : &quot;npm&quot;;const installOptions = [isYarn ? &quot;add&quot; : &quot;install&quot;, &quot;-D&quot;];console.error( `We will use &quot;${packageManager}&quot; to install the CLI via &quot;${packageManager} ${installOptions.join( &quot; &quot; )}&quot;.`);const question = `Do you want to install 'webpack-cli' (yes/no): `;const questionInterface = readLine.createInterface({ input: process.stdin, output: process.stderr});questionInterface.question(question, answer =&gt; { questionInterface.close(); const normalizedAnswer = answer.toLowerCase().startsWith(&quot;y&quot;); if (!normalizedAnswer) { console.error( &quot;You need to install 'webpack-cli' to use webpack via CLI.\\n&quot; + &quot;You can also install the CLI manually.&quot; ); process.exitCode = 1; return; } const packageName = &quot;webpack-cli&quot;; console.log( `Installing '${packageName}' (running '${packageManager} ${installOptions.join( &quot; &quot; )} ${packageName}')...` ); // 安装完webpack-cli 后 require 引入 runCommand(packageManager, installOptions.concat(packageName)) .then(() =&gt; { require(packageName); //eslint-disable-line }) .catch(error =&gt; { console.error(error); process.exitCode = 1; });}); 只安装了一个命令行工具123456789101112 const path = require(&quot;path&quot;); // 解析出package.json路径const pkgPath = require.resolve(`${installedClis[0].package}/package.json`);const pkg = require(pkgPath); // 注意: 这里是为了拼接引入bin命令的文件,而不是模块主入口(默认引入“main”字段)require(path.resolve( // package.json所在目录 path.dirname(pkgPath), // bin字段的入口文件相对路径 pkg.bin[installedClis[0].binName]));","link":"/2022/05/03/webpack-cli1/"},{"title":"tapable","text":"在阅读webpack的源码过程中,发现webpack编译的两个核心对象Compiler和Compilation都是继承自tapable, : Compiler: 负责整体编译流程的 Compilation: 负责编译Module 所以熟悉tapable还是很有必要的,而apable本质上实现了一种发布订阅模式. Tapable使用版本1&quot;tapable&quot;: &quot;^2.2.1&quot; 使用及分类官方一共提供了9种钩子 123456789101112const { SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook } = require(&quot;tapable&quot;); 基本使用 new 实例化一个钩子函数, 接收两个参数: 参数一: 为字符串数组, 数组中的值不重要,数组中个数对应后面监听方法tap的回调函数形参和触发事件方法call的实参个数; 参数二: 应用较少不需要额外介绍(官方文档也无体现) tap函数 监听对应的事件，注册事件时接受两个参数： 参数一: 字符串(作为标识位)或对象(可以额外设置触发优先级等) 参数二: 回调函数, 形参对应步骤1中参数一的字符串数组个数 call函数 触发步骤二中tap中的回调函数 分类按照同步/异步分类Tapable 中所有注册的事件可以分为同步、异步两种执行方式: 同步钩子: tap 方法是唯一的注册事件的方法，call 唯一调用方法 异步钩子可以通过 tap、tapAsync、tapPromise三种方式来注册，并依次通过对应的 call、callAsync、promise 三种方式触发注册的函数。 且异步钩子也分为两类: 异步串行( AsyncSeries )：可以被串联（连续按照顺序调用）执行的异步钩子。 异步并行( AsyncParallel )：可以被并联（并发调用）执行的异步钩子。 按照执行机制分类Tapable 可以按照异步/同步执行分类的同时也可以按照执行机制进行分类，比如： Basic Hook : 基本类型的钩子，它仅仅执行钩子注册的事件，并不关心每个被调用的事件函数返回值如何。 Bail : 保险类型钩子，保险类型钩子在基础类型钩子上增加了一种保险机制，如果任意一个注册函数执行返回非 undefined 的值，那么整个钩子执行过程会立即中断，之后注册事件函数就不会被调用了。 Waterfall : 瀑布类型的钩子，瀑布类型的钩子和基本类型的钩子基本类似，唯一不同的是瀑布类型的钩子会在注册的事件执行时将事件函数执行非 undefined 的返回值传递给接下来的事件函数作为参数。 Loop : 循环类型钩子，循环类型钩子稍微比较复杂一点。循环类型钩子通过 call 调用时，如果任意一个注册的事件函数返回值非 undefeind ,那么会立即重头开始重新执行所有的注册事件函数，直到所有被注册的事件函数都返回 undefined。 demo地址 参考资料 https://github.com/webpack/tapable https://juejin.cn/post/7040982789650382855#heading-3","link":"/2022/05/26/tapable/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"tools mac","slug":"tools-mac","link":"/tags/tools-mac/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"binary search tree","slug":"algorithm/binary-search-tree","link":"/categories/algorithm/binary-search-tree/"}]}