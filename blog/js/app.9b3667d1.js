(function(){"use strict";var s={812:function(s,l,n){var a=n(963),e=n(119),p=n(252);const k=(0,p._)("h2",null,"最近文章",-1),r=(0,p.Uk)("排序"),t=(0,p.Uk)("优先队列"),c=(0,p.Uk)("二叉搜索树"),_=(0,p.Uk)("2-3树"),o=(0,p.Uk)("红黑树");function h(s,l,n,a,e,h){const i=(0,p.up)("router-link");return(0,p.wg)(),(0,p.iD)(p.HY,null,[k,(0,p._)("ul",null,[(0,p._)("li",null,[(0,p.Wm)(i,{to:"/sort"},{default:(0,p.w5)((()=>[r])),_:1})]),(0,p._)("li",null,[(0,p.Wm)(i,{to:"/priority-queue"},{default:(0,p.w5)((()=>[t])),_:1})]),(0,p._)("li",null,[(0,p.Wm)(i,{to:"/bst"},{default:(0,p.w5)((()=>[c])),_:1})]),(0,p._)("li",null,[(0,p.Wm)(i,{to:"/2-3tree"},{default:(0,p.w5)((()=>[_])),_:1})]),(0,p._)("li",null,[(0,p.Wm)(i,{to:"/redBlackBST"},{default:(0,p.w5)((()=>[o])),_:1})])])],64)}var i={name:"About",data(){return{aboutMsg:"我是about组件"}}},j=n(744);const U=(0,j.Z)(i,[["render",h]]);var u=U;const y={class:"markdown-body"};function d(s,l,n,a,e,k){const r=(0,p.up)("SortMd");return(0,p.wg)(),(0,p.iD)("div",y,[(0,p.Wm)(r)])}const m=(0,p._)("html",null,[(0,p._)("head"),(0,p._)("body",null,[(0,p._)("h2",null,"排序"),(0,p._)("h3",null,"归并排序"),(0,p._)("p",null,"归并排序的性能不受输入数据的影响,为稳定排序算法, 速度仅次于快速排序."),(0,p._)("h4",null,"思想"),(0,p._)("p",null,"采用分治法Divide and Conquer）, 分治模式在每一层递归上有三个步骤:"),(0,p._)("ul",null,[(0,p._)("li",null,"分解（Divide）：将n个元素分成个含n/2个元素的子序列。"),(0,p._)("li",null,"解决（Conquer）：用合并排序法对两个子序列递归的排序。"),(0,p._)("li",null,"合并（Combine）：合并两个已排序的子序列已得到排序结果。")]),(0,p._)("h4",null,"实现逻辑(算法第四版 2.2.1):"),(0,p._)("p",null,"先将所有元素复制到aux[], 然后再归并到a[]中. 在归并时,进行4个条件判断:"),(0,p._)("ul",null,[(0,p._)("li",null,[(0,p._)("p",null,"左半边用尽(取右半边元素),")]),(0,p._)("li",null,[(0,p._)("p",null,"右半边用尽(取右半边元素),")]),(0,p._)("li",null,[(0,p._)("p",null,"右半边当前元素小于左半边当前元素(取右半边元素),")]),(0,p._)("li",null,[(0,p._)("p",null,"右半边当前元素小于等于左半边元素(取左半边元素)")])]),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-ts"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"function"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"merge"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("a: Comparable[], lo: "),(0,p._)("span",{class:"hljs-built_in"},"number"),(0,p.Uk)(", mid: "),(0,p._)("span",{class:"hljs-built_in"},"number"),(0,p.Uk)(", hi: "),(0,p._)("span",{class:"hljs-built_in"},"number")]),(0,p.Uk)(") {\n  "),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" i = lo; "),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" j = mid + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(";\n\n  "),(0,p._)("span",{class:"hljs-keyword"},"const"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-attr"},"aux"),(0,p.Uk)(": "),(0,p._)("span",{class:"hljs-title class_"},"Comparable"),(0,p.Uk)("[] = "),(0,p._)("span",{class:"hljs-title class_"},"Array"),(0,p.Uk)("."),(0,p._)("span",{class:"hljs-title function_"},"from"),(0,p.Uk)("(a);\n\n  "),(0,p._)("span",{class:"hljs-keyword"},"for"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" k = lo; k <= hi; k++) {\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("(i > mid) a[k] = aux[j++];\n    "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("( j > hi) a[k] = aux[i++];\n    "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-title function_"},"less"),(0,p.Uk)("(aux[j], aux[i])) a[k] = aux[j++];\n    "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(" a[k] = a[i++];\n  }\n}\n\n")])]),(0,p._)("h5",null,"递归法(2.2.2)"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-ts"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"function"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"mergeSort"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,p.Uk)(") {\n  "),(0,p._)("span",{class:"hljs-keyword"},"const"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-attr"},"aux"),(0,p.Uk)(": "),(0,p._)("span",{class:"hljs-title class_"},"Comparable"),(0,p.Uk)("[] = [];\n\n  "),(0,p._)("span",{class:"hljs-keyword"},"function"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("array: Comparable[], lo: "),(0,p._)("span",{class:"hljs-built_in"},"number"),(0,p.Uk)(", hi: "),(0,p._)("span",{class:"hljs-built_in"},"number")]),(0,p.Uk)(") {\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("(hi <= lo) "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(";\n    "),(0,p._)("span",{class:"hljs-keyword"},"const"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-attr"},"mid"),(0,p.Uk)(": "),(0,p._)("span",{class:"hljs-built_in"},"number"),(0,p.Uk)(" = lo + (hi - lo) / "),(0,p._)("span",{class:"hljs-number"},"2"),(0,p.Uk)(";\n\n    "),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("(array, lo, mid);\n    "),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("(array, mid + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", hi);\n\n    "),(0,p._)("span",{class:"hljs-title function_"},"merge"),(0,p.Uk)("(array, lo, mid , hi);\n  }\n\n  "),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("(arr, "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(" , arr."),(0,p._)("span",{class:"hljs-property"},"length"),(0,p.Uk)(" - "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(");\n\n  "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" arr;\n}\n\n")])]),(0,p._)("h5",null,"迭代法(2.2.3)"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-ts"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"function"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"mergeSort"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,p.Uk)(") {\n  "),(0,p._)("span",{class:"hljs-keyword"},"const"),(0,p.Uk)(" { length } = arr;\n  "),(0,p._)("span",{class:"hljs-keyword"},"const"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-attr"},"aux"),(0,p.Uk)(": "),(0,p._)("span",{class:"hljs-title class_"},"Comparable"),(0,p.Uk)("[] = [];\n\n  "),(0,p._)("span",{class:"hljs-keyword"},"for"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" sz = "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)("; sz < length; sz += sz + sz) { "),(0,p._)("span",{class:"hljs-comment"},"// sz 子数组大小"),(0,p.Uk)("\n    "),(0,p._)("span",{class:"hljs-keyword"},"for"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" lo = "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)("; lo < length - sz; lo += sz + sz) { "),(0,p._)("span",{class:"hljs-comment"},"// 子数组索引"),(0,p.Uk)("\n      "),(0,p._)("span",{class:"hljs-title function_"},"merge"),(0,p.Uk)("(arr, lo, lo + sz - "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", "),(0,p._)("span",{class:"hljs-title class_"},"Math"),(0,p.Uk)("."),(0,p._)("span",{class:"hljs-title function_"},"min"),(0,p.Uk)("(lo + sz + sz - "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", length -"),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)("))\n    }\n  }\n\n}\n\n")])]),(0,p._)("p",null,"不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )"),(0,p._)("p",null,"空间复杂度为: O(n)。"),(0,p._)("h3",null,"快速排序"),(0,p._)("p",null,"快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-ts"},[(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"function"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"quickSort"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,p.Uk)(") {\n    "),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("(arr, "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(", arr."),(0,p._)("span",{class:"hljs-property"},"lenght"),(0,p.Uk)(" - "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(");\n\n    "),(0,p._)("span",{class:"hljs-keyword"},"function"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-params"},"array: Comparable[], lo, hi"),(0,p.Uk)(") {\n      "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("(hi <= lo) "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(";\n\n      "),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" j = "),(0,p._)("span",{class:"hljs-title function_"},"partition"),(0,p.Uk)("(array, lo, hi); "),(0,p._)("span",{class:"hljs-comment"},"// 切分"),(0,p.Uk)("\n\n      "),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("(array, lo, j - "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(");\n      "),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p.Uk)("(array, j + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", hi);\n    }\n\n    "),(0,p._)("span",{class:"hljs-keyword"},"function"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"partition"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-params"},"array: Comparable[], lo , hi"),(0,p.Uk)(") {\n      "),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" i = lo; "),(0,p._)("span",{class:"hljs-keyword"},"let"),(0,p.Uk)(" j = hi + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(";\n\n      "),(0,p._)("span",{class:"hljs-keyword"},"const"),(0,p.Uk)(" v = array[lo];\n\n      "),(0,p._)("span",{class:"hljs-keyword"},"while"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-literal"},"true"),(0,p.Uk)(") {\n        "),(0,p._)("span",{class:"hljs-comment"},"// array[i] 小于v"),(0,p.Uk)("\n        "),(0,p._)("span",{class:"hljs-keyword"},"while"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-title function_"},"less"),(0,p.Uk)("(array[++i], v)) "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("(i == hi) "),(0,p._)("span",{class:"hljs-keyword"},"break"),(0,p.Uk)(";\n        "),(0,p._)("span",{class:"hljs-keyword"},"while"),(0,p.Uk)("("),(0,p._)("span",{class:"hljs-title function_"},"less"),(0,p.Uk)("(v, arry[--j])) "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("(j == lo) "),(0,p._)("span",{class:"hljs-keyword"},"break"),(0,p.Uk)(";\n\n        "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("(j <= i ) "),(0,p._)("span",{class:"hljs-keyword"},"break"),(0,p.Uk)(";\n        "),(0,p._)("span",{class:"hljs-title function_"},"exch"),(0,p.Uk)("(array, i, j);\n      }\n\n      "),(0,p._)("span",{class:"hljs-title function_"},"exch"),(0,p.Uk)("(array, lo, j);\n\n      "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" j;\n\n    }\n  }\n\n")])]),(0,p._)("p",null,[(0,p.Uk)("快速排序的平均时间复杂度是 O(nlogn), 但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 O(n2) "),(0,p._)("strong",null,"(即已经排序好的数组))"),(0,p.Uk)(" , 所以开始可以先打乱数组的顺序保持随机性.而且对于小数组,其实快速排序比插入排序慢;所以可以混合使用;")]),(0,p._)("p",null,"快速排序只是使用数组原本的空间进行排序;"),(0,p._)("p",null,"快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。"),(0,p._)("p",null,"快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。"),(0,p._)("h3",null,"堆排序"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"static"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"sort"),(0,p._)("span",{class:"hljs-params"},"(Comparable[] a)"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"N"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" a.length;\n   "),(0,p._)("span",{class:"hljs-keyword"},"for"),(0,p.Uk)(" ("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"k"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" N/"),(0,p._)("span",{class:"hljs-number"},"2"),(0,p.Uk)("; k >= "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)("; k--)\n      sink(a, k, N);\n   "),(0,p._)("span",{class:"hljs-keyword"},"while"),(0,p.Uk)(" (N > "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(")\n   {\n      exch(a, "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", N--);\n      sink(a, "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", N);\n   }\n}\n")])]),(0,p._)("p",null,[(0,p.Uk)("以上代码中,第一个循环,构造了一个二叉堆, 第二个循环,依次将堆顶元素和最后一个元素交换,并通过缩小数组N的值来弹出原堆顶 "),(0,p._)("strong",null,"(最值)"),(0,p.Uk)(" 缩小堆的大小.")]),(0,p._)("p",null,[(0,p.Uk)("在前面文章 "),(0,p._)("strong",null,"(优先队列)"),(0,p.Uk)(" 里介绍过的,由数组构造的二叉堆中,父节点位置为"),(0,p._)("strong",null,"k"),(0,p.Uk)("时,子节点分别为"),(0,p._)("strong",null,"2k"),(0,p.Uk)("和"),(0,p._)("strong",null,"2k+1"),(0,p.Uk)(",所以从 "),(0,p._)("strong",null,"N/2"),(0,p.Uk)("的位置找到最大的父节点,并依次"),(0,p._)("strong",null,"sink"),(0,p.Uk)("操作(sink操作见优先队列),从而达到堆有序.")]),(0,p._)("p",null,"如下图:"),(0,p._)("p",null,[(0,p._)("img",{src:"assets/%E5%A0%86%E6%8E%92%E5%BA%8F.png",alt:"堆排序"})])])],-1),w=[m];function f(s,l){return(0,p.wg)(),(0,p.iD)("section",null,w)}const g={},b=(0,j.Z)(g,[["render",f]]);var v=b,E=(n(29),{components:{SortMd:v}});const x=(0,j.Z)(E,[["render",d]]);var B=x;const N={class:"markdown-body"};function A(s,l,n,a,e,k){const r=(0,p.up)("PriorityQueueMd");return(0,p.wg)(),(0,p.iD)("div",N,[(0,p.Wm)(r)])}const q=(0,p._)("html",null,[(0,p._)("head"),(0,p._)("body",null,[(0,p._)("h2",null,"优先队列 (算法第四版2.4)"),(0,p._)("p",null,"普通队列是一种先进先出的数据结构，先放进队列的元素取值时优先被取出来。而优先队列是一种具有最高优先级元素先出的数据结构，比如每次取值都取最大的元素, 它包含最重要的两种操作: 删除最大元素delMax和插入元素insert()."),(0,p._)("h3",null,"堆的定义"),(0,p._)("p",null,"当一颗二叉树的每个节点都大于等于它的两个子节点时,它被称为堆有序, 所以根节点是堆有序的二叉树中的最大节点"),(0,p._)("h3",null,"二叉堆表示法"),(0,p._)("h4",null,"完全二叉树的定义"),(0,p._)("p",null,"二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）"),(0,p._)("h4",null,"数组表示完全二叉树"),(0,p._)("p",null,"如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）. 如果我们使用完全二叉树，表达就会变得特别方便"),(0,p._)("p",null,[(0,p.Uk)("完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。 "),(0,p._)("strong",null,"（不使用数组的第一个位置, 哨兵）")]),(0,p._)("p",null,[(0,p._)("strong",null,"简单起见，在下文中我们将二叉堆简称为堆）"),(0,p.Uk)(" 在一个堆中，位置 "),(0,p._)("strong",null,"k"),(0,p.Uk)(" 的结点的父结点的位置为 "),(0,p._)("strong",null,"k / 2"),(0,p.Uk)("而它的两个子结点的位置则分别为 "),(0,p._)("strong",null,"2k"),(0,p.Uk)(" 和 "),(0,p._)("strong",null,"2k+1"),(0,p.Uk)("。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1。")]),(0,p._)("blockquote",null,[(0,p._)("p",null,[(0,p._)("strong",null,"命题 P"),(0,p.Uk)("。一棵大小为 "),(0,p._)("strong",null,"N"),(0,p.Uk)(" 的完全二叉树的高度为 "),(0,p._)("strong",null,"lgN"),(0,p.Uk)("。")])]),(0,p._)("blockquote",null,[(0,p._)("p",null,[(0,p._)("strong",null,"证明"),(0,p.Uk)("。通过归纳很容易可以证明这一点，且当 达到 2 的幂时树的高度会加 1。")])]),(0,p._)("h3",null,"堆的算法"),(0,p._)("p",null,[(0,p.Uk)("我们用长度为 "),(0,p._)("strong",null,"k + 1"),(0,p.Uk)(" 的私有数组 pq[] 来表示一个大小为 "),(0,p._)("strong",null,"k"),(0,p.Uk)(" 的堆，我们不会使用 pq[0]，堆元素放在 pq[1] 至 pq[N] 中")]),(0,p._)("h4",null,"堆实现的比较和交换方法"),(0,p._)("p",null,"因为所有的元素都在数组 pq[] 中，不再将数组作为参数传递"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"less"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" i, "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" j)")]),(0,p.Uk)("\n{  "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" pq[i].compareTo(pq[j]) < "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(";  }\n\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"exch"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" i, "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" j)")]),(0,p.Uk)("\n{  "),(0,p._)("span",{class:"hljs-type"},"Key"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"t"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" pq[i]; pq[i] = pq[j]; pq[j] = t;  }\n\n")])]),(0,p._)("h4",null,"由下自上的堆有序化（上浮）"),(0,p._)("p",null,"当调用优先队列的insert方法时，我们首先把元素放置到数组的结尾，然后再把该元素上浮到正确的节点，最终形成堆有序状态。"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"swim"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" k)")]),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"while"),(0,p.Uk)(" (k > "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(" && less(k/"),(0,p._)("span",{class:"hljs-number"},"2"),(0,p.Uk)(", k))\n   {\n      exch(k/"),(0,p._)("span",{class:"hljs-number"},"2"),(0,p.Uk)(", k);\n      k = k/"),(0,p._)("span",{class:"hljs-number"},"2"),(0,p.Uk)(";\n   }\n}\n\n\n")])]),(0,p._)("h4",null,"由上至下的堆有序化（下沉）"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"sink"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" k)")]),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"while"),(0,p.Uk)(" ("),(0,p._)("span",{class:"hljs-number"},"2"),(0,p.Uk)("*k <= N)\n   {\n      "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"j"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(),(0,p._)("span",{class:"hljs-number"},"2"),(0,p.Uk)("*k;\n      "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (j < N && less(j, j+"),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(")) j++;\n      "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (!less(k, j)) "),(0,p._)("span",{class:"hljs-keyword"},"break"),(0,p.Uk)(";\n      exch(k, j);\n      k = j;\n   }\n}\n\n")])]),(0,p._)("p",null,[(0,p._)("img",{src:"'../assets/%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C.png'",alt:"堆的操作"})]),(0,p._)("h4"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"class"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"MaxPQ"),(0,p.Uk)("<Key "),(0,p._)("span",{class:"hljs-keyword"},"extends"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Comparable"),(0,p.Uk)("<Key>>\n{\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Key[] pq;             "),(0,p._)("span",{class:"hljs-comment"},"// 基于堆的完全按二叉树”"),(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"N"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(";            "),(0,p._)("span",{class:"hljs-comment"},"// 存储于pq[1..N]中，pq[0]没有使用"),(0,p.Uk)("\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"MaxPQ"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" maxN)")]),(0,p.Uk)("\n   {  pq = (Key[]) "),(0,p._)("span",{class:"hljs-keyword"},"new"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Comparable"),(0,p.Uk)("[maxN+"),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)("];  }\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"isEmpty"),(0,p._)("span",{class:"hljs-params"},"()"),(0,p.Uk)("\n   {  "),(0,p._)("span",{class:"hljs-type"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"N"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)("= "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(";  }\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"size"),(0,p._)("span",{class:"hljs-params"},"()"),(0,p.Uk)("\n   {  "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" N;  }\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"insert"),(0,p._)("span",{class:"hljs-params"},"(Key v)"),(0,p.Uk)("\n   {\n      pq[++N] = v;\n      swim(N);\n   }\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(" Key "),(0,p._)("span",{class:"hljs-title function_"},"delMax"),(0,p._)("span",{class:"hljs-params"},"()"),(0,p.Uk)("\n   {\n      "),(0,p._)("span",{class:"hljs-type"},"Key"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"max"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" pq["),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)("];           "),(0,p._)("span",{class:"hljs-comment"},"// 从根结点得到最大元素"),(0,p.Uk)("\n      exch("),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", N--);              "),(0,p._)("span",{class:"hljs-comment"},"// 将其和最后一个结点交换"),(0,p.Uk)("\n      pq[N+"),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)("] = "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(";            "),(0,p._)("span",{class:"hljs-comment"},"// 防止对象游离"),(0,p.Uk)("\n      sink("),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(");                   "),(0,p._)("span",{class:"hljs-comment"},"// 恢复堆的有序性"),(0,p.Uk)("\n      "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" max;\n   }\n\n   "),(0,p._)("span",{class:"hljs-comment"},"// 辅助方法的实现请见本节前面的代码框"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"less"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" i, "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" j)")]),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"exch"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" i, "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" j)")]),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"swim"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" k)")]),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"sink"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" k)")]),(0,p.Uk)("\n}\n\n")])]),(0,p._)("p",null,"优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。在 insert() 中，我们将 N 加一并把新元素添加在数组最后，然后用 swim() 恢复堆的秩序。在 delMax() 中，我们从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink() 恢复堆的秩序。同时我们还将不再使用的 pq[N+1] 设为 null，以便系统回收它所占用的空间。这里省略了动态调整数组大小的代码"),(0,p._)("blockquote",null,[(0,p._)("p",null,[(0,p._)("strong",null,"命题 Q"),(0,p.Uk)("。对于一个含有 "),(0,p._)("strong",null,"N"),(0,p.Uk)(" 个元素的基于堆的优先队列，插入元素操作只需不超过（"),(0,p._)("strong",null,"lgN + 1"),(0,p.Uk)("）次比较，删除最大元素的操作需要不超过 "),(0,p._)("strong",null,"2lgN"),(0,p.Uk)(" 次比较。")])]),(0,p._)("blockquote",null,[(0,p._)("p",null,[(0,p._)("strong",null,"证明"),(0,p.Uk)("。由命题 P 可知，两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过 "),(0,p._)("strong",null,"lgN"),(0,p.Uk)("。对于路径上的每个结点，删除最大元素需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。")])])])],-1),K=[q];function C(s,l){return(0,p.wg)(),(0,p.iD)("section",null,K)}const z={},D=(0,j.Z)(z,[["render",C]]);var M=D,R={name:"PriorityQueue",components:{PriorityQueueMd:M}};const T=(0,j.Z)(R,[["render",A]]);var F=T;const O={class:"markdown-body"};function V(s,l,n,a,e,k){const r=(0,p.up)("BstMd");return(0,p.wg)(),(0,p.iD)("div",O,[(0,p.Wm)(r)])}const S=(0,p._)("html",null,[(0,p._)("head"),(0,p._)("body",null,[(0,p._)("h2",null,"二叉搜索树"),(0,p._)("h3",null,"定义"),(0,p._)("p",null,"一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键."),(0,p._)("p",null,"每一个二叉搜索树的左右子树也都是一个二叉搜索树"),(0,p._)("p",null,"二叉搜索树如果用中序遍历一下，就是一个从大到小的序列"),(0,p._)("h3",null,"二叉查找树的建立"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"class"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"BST"),(0,p.Uk)("<Key "),(0,p._)("span",{class:"hljs-keyword"},"extends"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Comparable"),(0,p.Uk)("<Key>, Value>\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node root;               "),(0,p._)("span",{class:"hljs-comment"},"// 二叉查找树的根结点"),(0,p.Uk)("\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"class"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Node"),(0,p.Uk)("\n   {\n      "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Key key;              "),(0,p._)("span",{class:"hljs-comment"},"// 键"),(0,p.Uk)("\n      "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Value val;            "),(0,p._)("span",{class:"hljs-comment"},"// 值"),(0,p.Uk)("\n      "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node left, right;     "),(0,p._)("span",{class:"hljs-comment"},"// 指向子树的链接"),(0,p.Uk)("\n      "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" N;                "),(0,p._)("span",{class:"hljs-comment"},"// 以该结点为根的子树中的结点总数"),(0,p.Uk)("\n\n      "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"Node"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("(Key key, Value val, "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" N)")]),(0,p.Uk)("\n      {  "),(0,p._)("span",{class:"hljs-built_in"},"this"),(0,p.Uk)(".key = key; "),(0,p._)("span",{class:"hljs-built_in"},"this"),(0,p.Uk)(".val = val; "),(0,p._)("span",{class:"hljs-built_in"},"this"),(0,p.Uk)(".N = N; }\n   }\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"size"),(0,p._)("span",{class:"hljs-params"},"()"),(0,p.Uk)("\n   {  "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" size(root);  }\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"size"),(0,p._)("span",{class:"hljs-params"},"(Node x)"),(0,p.Uk)("\n   {\n      "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(";\n      "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)("           "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x.N;\n   }\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(" Value "),(0,p._)("span",{class:"hljs-title function_"},"get"),(0,p._)("span",{class:"hljs-params"},"(Key key)"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-comment"},"// 请见算法3.3（续1）"),(0,p.Uk)("\n\n   "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"put"),(0,p._)("span",{class:"hljs-params"},"(Key key, Value val)"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-comment"},"// 请见算法3.3（续1）"),(0,p.Uk)("\n\n   "),(0,p._)("span",{class:"hljs-comment"},"// max()、min()、floor()、ceiling()方法请见算法3.3（续2）"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-comment"},"// select()、rank()方法请见算法3.3（续3）"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-comment"},"// delete()、deleteMin()、deleteMax()方法请见算法3.3（续4）"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-comment"},"// keys()方法请见算法3.3（续5）"),(0,p.Uk)("\n}\n\n")])]),(0,p._)("h3",null,"算法 3.3（续 1）二叉查找树的查找和赋值"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-comment"},"/*查找*/"),(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(" Value "),(0,p._)("span",{class:"hljs-title function_"},"get"),(0,p._)("span",{class:"hljs-params"},"(Key key)"),(0,p.Uk)("\n{  "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" get(root, key);  }\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Value "),(0,p._)("span",{class:"hljs-title function_"},"get"),(0,p._)("span",{class:"hljs-params"},"(Node x, Key key)"),(0,p.Uk)("\n{  "),(0,p._)("span",{class:"hljs-comment"},"// 在以x为根结点的子树中查找并返回key所对应的值；"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-comment"},"// 如果找不到则返回null"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"cmp"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" key.compareTo(x.key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("      (cmp < "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" get(x.left, key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp > "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" get(x.right, key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x.val;\n}\n"),(0,p._)("span",{class:"hljs-comment"},"/*赋值*/"),(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"put"),(0,p._)("span",{class:"hljs-params"},"(Key key, Value val)"),(0,p.Uk)("\n{  "),(0,p._)("span",{class:"hljs-comment"},"// 查找key，找到则更新它的值，否则为它创建一个新的结点"),(0,p.Uk)("\n   root = put(root, key, val);\n}\n\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"put"),(0,p._)("span",{class:"hljs-params"},"(Node x, Key key, Value val)"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-comment"},"// 如果key存在于以x为根结点的子树中则更新它的值；"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-comment"},"// 否则将以key和val为键值对的新结点插入到该子树中"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"new"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Node"),(0,p.Uk)("(key, val, "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(");\n   "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"cmp"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" key.compareTo(x.key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("      (cmp < "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") x.left  = put(x.left,  key, val);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp > "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") x.right = put(x.right, key, val);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(" x.val = val;\n   x.N = size(x.left) + size(x.right) + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x;\n}\n\n")])]),(0,p._)("h3",null,"分析二叉查找树查找节点的时间复杂度(节点数为N)"),(0,p._)("p",null,"最差情况下,二叉查找树退化成链表,树高等于节点也为N"),(0,p._)("p",null,[(0,p.Uk)("理想情况下,一颗含有N个节点的二叉查找树是完全平衡的,及每条空链接到空节点的距离"),(0,p._)("strong",null,"相等"),(0,p.Uk)("都为"),(0,p._)("strong",null,"lgN"),(0,p.Uk)(",也就是树高为 "),(0,p._)("strong",null,"lgN")]),(0,p._)("p",null,[(0,p.Uk)("二叉查找树的查找的平均时间复杂度为~2InN,约为"),(0,p._)("strong",null,"1.39lgN"),(0,p.Uk)(",比二分查找的成本高约"),(0,p._)("strong",null,"39%")]),(0,p._)("h3",null,"最大键最小键 及 向上取整和向下取整"),(0,p._)("h4",null,"最大键最小键"),(0,p._)("p",null,"如果根节点左链接为空为空,则一颗二叉查找树的最小节点是根节点.如果左子树非空,那么树中最小键也是左子树的最小键."),(0,p._)("p",null,"最大键相反"),(0,p._)("h4",null,"向上取整和向下取整"),(0,p._)("p",null,[(0,p.Uk)("如果给定的键key小于二叉查找树根节点,那么"),(0,p._)("strong",null,"小于等于"),(0,p.Uk)("key的最大键**floor(key)**一定在根节点的左子树中;如果给定的键key大于二叉查找树的根节点,只有当根节点的右节点存在小于等于key的节点,小于等于key的最大键才会存在于右子树中,否则根节点就是小于等于key的最大键")]),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(" Key "),(0,p._)("span",{class:"hljs-title function_"},"min"),(0,p._)("span",{class:"hljs-params"},"()"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" min(root).key;\n}\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"min"),(0,p._)("span",{class:"hljs-params"},"(Node x)"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x.left == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x;\n   "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" min(x.left);\n}\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(" Key "),(0,p._)("span",{class:"hljs-title function_"},"floor"),(0,p._)("span",{class:"hljs-params"},"(Key key)"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-type"},"Node"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"x"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" floor(root, key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x.key;\n}\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"floor"),(0,p._)("span",{class:"hljs-params"},"(Node x, Key key)"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"cmp"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" key.compareTo(x.key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp == "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x;\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp < "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(")  "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" floor(x.left, key);\n   "),(0,p._)("span",{class:"hljs-type"},"Node"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"t"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" floor(x.right, key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (t != "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" t;\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)("           "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x;\n}\n\n")])]),(0,p._)("h3",null,"排名"),(0,p._)("h4",null,"select()"),(0,p._)("p",null,"假设我们想找到排名为 的键（即树中正好有 个小于它的键）。如果左子树中的结点数 大于 ，那么我们就继续（递归地）在左子树中查找排名为 的键；如果 等于 ，我们就返回根结点中的键；如果 小于 ，我们就（递归地）在右子树中查找排名为（）的键。"),(0,p._)("h4",null,"rank()"),(0,p._)("p",null,"rank() 是 select() 的逆方法，它会返回给定键的排名。它的实现和 select() 类似：如果给定的键和根结点的键相等，我们返回左子树中的结点总数 ；如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）；如果给定的键大于根结点，我们会返回 （根结点）加上它在右子树中的排名（递归计算）"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(" Key "),(0,p._)("span",{class:"hljs-title function_"},"select"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("("),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" k)")]),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" select(root, k).key;\n}\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"select"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("(Node x, "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" k)")]),(0,p.Uk)("\n{   "),(0,p._)("span",{class:"hljs-comment"},"// 返回排名为k的结点"),(0,p.Uk)("\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(";\n    "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"t"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" size(x.left);\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("      (t > k) "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" select(x.left,  k);\n    "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (t < k) "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" select(x.right, k-t-"),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(");\n    "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)("            "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x;\n}\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"rank"),(0,p._)("span",{class:"hljs-params"},"(Key key)"),(0,p.Uk)("\n{  "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" rank(key, root);  }\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"rank"),(0,p._)("span",{class:"hljs-params"},"(Key key, Node x)"),(0,p.Uk)("\n{  "),(0,p._)("span",{class:"hljs-comment"},"// 返回以x为根结点的子树中小于x.key的键的数量"),(0,p.Uk)("\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"cmp"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" key.compareTo(x.key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("      (cmp < "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" rank(key, x.left);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp > "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(" + size(x.left) + rank(key, x.right);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)("              "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" size(x.left);\n}\n\n")])]),(0,p._)("h3",null,"删除delete()"),(0,p._)("h4",null,"删除最大最小键"),(0,p._)("p",null,[(0,p.Uk)("二叉查找树中最难实现的方法就是 "),(0,p._)("strong",null,"delete()"),(0,p.Uk)(" 方法，即从符号表中删除一个键值对”, 在此之前我们先考虑 "),(0,p._)("strong",null,"deleteMin()"),(0,p.Uk)(" 方法")]),(0,p._)("p",null,"和 put() 一样，我们的递归方法接受一个指向结点的链接，并返回一个指向结点的链接。这样我们就能够方便地改变树的结构，将返回的链接赋给作为参数的链接。对于 deleteMin()，我们要不断深入根结点的左子树中直至遇见一个空链接，然后将指向该结点的链接指向该结点的右子树（只需要在递归调用中返回它的右链接即可）。此时已经没有任何链接指向要被删除的结点，因此它会被垃圾收集器清理掉. deleteMax() 方法的实现和 deleteMin() 完全类似。"),(0,p._)("h4",null,"删除操作"),(0,p._)("p",null,"我们可以用类似的方式删除任意只有一个子结点（或者没有子结点）的结点，但应该怎样删除一个拥有两个子结点的结点呢？"),(0,p._)("p",null,"删除之后我们要处理两棵子树，但被删除结点的父结点只有一条空出来的链接。T. Hibbard 在 1962 年提出了解决这个难题的第一个方法，在删除结点 x 后用它的后继结点填补它的位置。因为 x 有一个右子结点，因此它的后继结点就是其右子树中的最小结点。这样的替换仍然能够保证树的有序性，因为 x.key 和它的后继结点的键之间不存在其他的键"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"deleteMin"),(0,p._)("span",{class:"hljs-params"},"()"),(0,p.Uk)("\n{\n   root = deleteMin(root);\n}\n\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"deleteMin"),(0,p._)("span",{class:"hljs-params"},"(Node x)"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x.left == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x.right;\n   x.left = deleteMin(x.left);\n   x.N = size(x.left) + size(x.right) + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x;\n   }\n\n"),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"delete"),(0,p._)("span",{class:"hljs-params"},"(Key key)"),(0,p.Uk)("\n{  root = delete(root, key);  }\n\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"delete"),(0,p._)("span",{class:"hljs-params"},"(Node x, Key key)"),(0,p.Uk)("\n{\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"cmp"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" key.compareTo(x.key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)("      (cmp < "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") x.left  = delete(x.left,  key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp > "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") x.right = delete(x.right, key);\n   "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)("\n   {\n      "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x.right == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x.left;\n      "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x.left == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x.right;\n      "),(0,p._)("span",{class:"hljs-type"},"Node"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"t"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" x;\n      x = min(t.right);  "),(0,p._)("span",{class:"hljs-comment"},"// 请见算法3.3（续2）"),(0,p.Uk)("\n      x.right = deleteMin(t.right);\n      x.left = t.left;\n   }\n   x.N = size(x.left) + size(x.right) + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(";\n   "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x;\n}\n\n")])])])],-1),Z=[S];function P(s,l){return(0,p.wg)(),(0,p.iD)("section",null,Z)}const W={},Q=(0,j.Z)(W,[["render",P]]);var L=Q,H={name:"Bst",components:{BstMd:L}};const I=(0,j.Z)(H,[["render",V]]);var Y=I;const G=(0,p.uE)('<html><head></head><body><h2>2-3树</h2><p>上文说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为<strong>N</strong>,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了<strong>2-3树</strong>概念</p><h3>定义</h3><p>为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成:</p><ul><li><p>2-节点: 标准的二叉查找树中的节点.含有<strong>一个键</strong>（及其对应的值）和<strong>两条链接</strong>,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。</p></li><li><p>3-节点: 含有<strong>两个键</strong>（及其对应的值）和<strong>三条链接</strong>，<strong>左链接</strong>指向的 目标节点的键都<strong>小于</strong>该结点，中链接指向的 目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。</p></li></ul><h3>查找</h3><p>将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中</p><p><img src="assets/2-3%E6%A0%91%E6%9F%A5%E6%89%BE.png" alt="2-3树查找的命中与未命中"></p><h3>插入</h3><p>空树的插入很简单,创建一个节点即可.非空树则分四种情况:</p><ul><li><p>向2-节点中插入元素；</p></li><li><p>向一颗只含有一个3-节点的树中插入元素；</p></li><li><p>向一个父节点为2-节点的3-节点中插入元素；</p></li><li><p>向一个父节点为3-节点的3-节点中插入元素</p></li></ul><h4>向2-节点中插入元素</h4><p>如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点</p><p><img src="assets/%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E9%94%AE.png" alt="向2-结点中插入新的键"></p><h4>向一颗只含有一个3-节点的树中插入元素</h4><p>我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树</p><p><img src="assets/%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%AA%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AA3-%E7%BB%93%E7%82%B9%E7%9A%84%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE.png" alt="向一棵只含有一个 3- 结点的树中插入新键"></p><h4>向一个父节点为2-节点的3-节点中插入元素</h4><p>我们先像刚才一样构造一个临时的 4- 结点并将其分解, 但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中, 父结点是一个 2- 结点（一个键两条链接）， 插入之后变为了一个 3- 结点. 这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的， 插入后所有的空链接到根结点的距离仍然相同</p><p><img src="assets/%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA2-%E8%8A%82%E7%82%B9%E7%9A%843-%E8%8A%82%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png" alt="向一个父节点为2-节点的3-节点中插入元素"></p><h4>向一个父节点为3-节点的3-节点中插入元素</h4><p>再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点， 然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况， 我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根</p><p><img src="assets/%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA3-%E8%8A%82%E7%82%B9%E7%9A%843-%E8%8A%82%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0.png" alt="向一个父节点为3-节点的3-节点中插入元素"></p><p>分解根节点</p><p><img src="assets/%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA3-%E8%8A%82%E7%82%B9%E7%9A%843-%E8%8A%82%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0-%E5%88%86%E8%A7%A3%E8%B7%9F%E5%85%83%E7%B4%A0.png" alt="向一个父节点为3-节点的3-节点中插入元素-分解跟元素"></p><p>2-3树节点关系</p><p><img src="assets/2-3%E6%A0%91%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.png" alt="2-3树节点关系"></p><p>2-3树构造轨迹, 即使升序插入也不会退化为链表,如下图右所示:</p><p><img src="assets/2-3%E6%A0%91%E6%9E%84%E9%80%A0%E8%BD%A8%E8%BF%B9.png" alt="2-3树构造轨迹"></p><h3>性质:</h3><p>和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的</p><blockquote><p><strong>命题 F</strong>在一棵大小为 的 2-3 树中，查找和插入操作访问的结点必然不超过<strong>lgN</strong></p></blockquote><blockquote><p><strong>证明</strong>。一棵含有 N 个结点的 2-3 树的高度在 <strong>log3 N</strong>（如果树中全是 3- 结点）和 <strong>log2 N</strong>（如果树中全是 2- 结点）之间</p></blockquote></body></html>',1),J=[G];function X(s,l){return(0,p.wg)(),(0,p.iD)("section",null,J)}const $={},ss=(0,j.Z)($,[["render",X]]);var ls=ss;const ns={class:"markdown-body"};function as(s,l,n,a,e,k){const r=(0,p.up)("RedBlackBSTMd");return(0,p.wg)(),(0,p.iD)("div",ns,[(0,p.Wm)(r)])}const es=(0,p._)("html",null,[(0,p._)("head"),(0,p._)("body",null,[(0,p._)("h2",null,"红黑树二叉搜索树"),(0,p._)("p",null,[(0,p.Uk)("上文中2-3树可以实现树的"),(0,p._)("strong",null,"有序性"),(0,p.Uk)("与"),(0,p._)("strong",null,"平衡性"),(0,p.Uk)(",但是要维护两种不同类型的节点(2-节点与"),(0,p._)("strong",null,"3-节点"),(0,p.Uk)("),将被查找的键和结点中的每个键 进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到 另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会 使算法比标准的二叉查找树更慢.")]),(0,p._)("h3",null,"替换3-节点"),(0,p._)("p",null,[(0,p.Uk)("红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由 2- 结点构成）和一些额外的 信息（替换 3- 结点）来表示 2-3 树.树的链接分为两种: "),(0,p._)("strong",null,"红链接"),(0,p.Uk)("将两个 2- 结点 连接起来构成一个 3- 结点;"),(0,p._)("strong",null,"黑链接"),(0,p.Uk)("则是 2-3 树中的普通链接。")]),(0,p._)("p",null,[(0,p._)("img",{src:"assets/%E7%BA%A2%E9%93%BE%E6%8E%A5%E7%9B%B8%E8%BF%9E%E7%9A%84%E4%B8%A4%E4%B8%AA2%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA3%E8%8A%82%E7%82%B9.png",alt:"红链接相连的两个2节点表示3节点"})]),(0,p._)("h3",null,"定义"),(0,p._)("p",null,"红黑树是含有红黑链接并满足下列条件的二叉查找树："),(0,p._)("ul",null,[(0,p._)("li",null,"红链接均为左链接；"),(0,p._)("li",null,"没有任何一个结点同时和两条红链接相连；"),(0,p._)("li",null,"该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。")]),(0,p._)("p",null,"满足这样定义的红黑树和相应的 2-3 树是一一对应的"),(0,p._)("p",null,[(0,p._)("img",{src:"assets/%E7%BA%A2%E9%93%BE%E6%8E%A5%E7%94%BB%E5%B9%B3%E5%8F%98%E6%88%902-3%E6%A0%91.png",alt:"红链接画平变成2-3树"})]),(0,p._)("h3",null,"节点表示"),(0,p._)("p",null,"每个结点都只会有一条指向自己的链接（从它的父结点指向它）, 我们将节点颜色保存在Node这个对象中,且当我们提到一个结点的颜色时，我们指的是指向 该结点的链接的颜色"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p.Uk)("\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"static"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"final"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"RED"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"true"),(0,p.Uk)(";\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"static"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"final"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"BLACK"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"false"),(0,p.Uk)(";\n\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"class"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Node"),(0,p.Uk)(" {\n    Key key;                 "),(0,p._)("span",{class:"hljs-comment"},"//键"),(0,p.Uk)("\n    Value val;               "),(0,p._)("span",{class:"hljs-comment"},"//值"),(0,p.Uk)("\n    Node left, right;      "),(0,p._)("span",{class:"hljs-comment"},"//左右链接"),(0,p.Uk)("\n    "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" N;                      "),(0,p._)("span",{class:"hljs-comment"},"//这颗子树中的结点总数"),(0,p.Uk)("\n    "),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(" color;       "),(0,p._)("span",{class:"hljs-comment"},"//由父结点指向它的链接的颜色"),(0,p.Uk)("\n\n    "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"Node"),(0,p._)("span",{class:"hljs-params"},[(0,p.Uk)("(Key key, Value val, "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(" N, "),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(" color)")]),(0,p.Uk)(" {\n        "),(0,p._)("span",{class:"hljs-built_in"},"this"),(0,p.Uk)(".key = key;\n        "),(0,p._)("span",{class:"hljs-built_in"},"this"),(0,p.Uk)(".val = val;\n        "),(0,p._)("span",{class:"hljs-built_in"},"this"),(0,p.Uk)(".N = N;\n        "),(0,p._)("span",{class:"hljs-built_in"},"this"),(0,p.Uk)(".color = color;\n    } \n}\n\n"),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"isRed"),(0,p._)("span",{class:"hljs-params"},"(Node x)"),(0,p.Uk)(" {\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (x == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-literal"},"false"),(0,p.Uk)(";\n    "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" x.color == RED;\n}\n\n")])]),(0,p._)("p",null,"每次插入的节点的时候都将节点的颜色初始化为红色"),(0,p._)("h3",null,"旋转"),(0,p._)("p",null,[(0,p.Uk)("在我们实现的某些操作中(比如插入)可能会出现红色右链接或者两条连续的红链接, 需要通过"),(0,p._)("strong",null,"旋转"),(0,p.Uk)("和"),(0,p._)("strong",null,"变换颜色"),(0,p.Uk)("修复, 旋转操作会改变红链接的指向,")]),(0,p._)("h4",null,"左旋转"),(0,p._)("p",null,[(0,p._)("img",{src:"assets/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B%E8%BD%AC.png",alt:"红黑树左旋转"})]),(0,p._)("h4",null,"右旋转"),(0,p._)("p",null,[(0,p._)("img",{src:"assets/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8B%E8%BD%AC.png",alt:"红黑树右旋转"})]),(0,p._)("p",null,"无论是rotateRight()或rotateLeft() , 我们总是将其返回值重置父结点（或是根结点),且保留原来父节点的颜色(将 x.color 设为 h.color)"),(0,p._)("h3",null,"颜色变换"),(0,p._)("p",null,"当我们的节点经过左右旋转时,有可能出现左右节点均为红色的场景,此时,我们需要颜色变换."),(0,p._)("p",null,[(0,p.Uk)("我们专门用一个方法 "),(0,p._)("strong",null,"flipColors()"),(0,p.Uk)(" 来转换一个结点的两个红色子结点 的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将"),(0,p._)("strong",null,"父结点的颜色由黑变红"),(0,p.Uk)("(相当于父节点上浮,和它的父节点结合成为一个3-节点),这项 操作和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性.")]),(0,p._)("p",null,[(0,p._)("img",{src:"assets/%E7%BA%A2%E9%BB%91%E6%A0%91%E9%A2%9C%E8%89%B2%E5%8F%98%E6%8D%A2.png",alt:"红黑树颜色变换"})]),(0,p._)("h3",null,"红黑树的链接向上传递"),(0,p._)("p",null,"只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作, 在沿着插入点到根结点的路径向上移动时在所经过 的每个结点中顺序完成以下操作，我们就能完成插入操作："),(0,p._)("ul",null,[(0,p._)("li",null,"如果右子结点是红色的而左子结点是黑色的，进行左旋转；"),(0,p._)("li",null,"如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；"),(0,p._)("li",null,"如果左右子结点均为红色，进行颜色转换。")]),(0,p._)("p",null,"注意,红黑树的根节点为黑色!"),(0,p._)("h3",null,"实现插入"),(0,p._)("pre",null,[(0,p._)("code",{"v-pre":"",class:"language-java"},[(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"class"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"RedBlackBST"),(0,p.Uk)("<Key "),(0,p._)("span",{class:"hljs-keyword"},"extends"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Comparable"),(0,p.Uk)("<Key>, Value>\n{\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node root;\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"class"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Node"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-comment"},"// 含有color变量的Node对象（请见3.3.2.4节）"),(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"boolean"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"isRed"),(0,p._)("span",{class:"hljs-params"},"(Node h)"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-comment"},"// 请见3.3.2.4节"),(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"rotateLeft"),(0,p._)("span",{class:"hljs-params"},"(Node h)"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-comment"},"// 请见图3.3.16"),(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"rotateRight"),(0,p._)("span",{class:"hljs-params"},"(Node h)"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-comment"},"// 请见图3.3.17"),(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"flipColors"),(0,p._)("span",{class:"hljs-params"},"(Node h)"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-comment"},"// 请见图3.3.21"),(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"size"),(0,p._)("span",{class:"hljs-params"},"()"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-comment"},"// 请见算法3.3"),(0,p.Uk)("\n  "),(0,p._)("span",{class:"hljs-keyword"},"public"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"void"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title function_"},"put"),(0,p._)("span",{class:"hljs-params"},"(Key key, Value val)"),(0,p.Uk)("\n  { "),(0,p._)("span",{class:"hljs-comment"},"// 查找key，找到则更新其值，否则为它新建一个结点"),(0,p.Uk)("\n  root = put(root, key, val);\n  root.color = BLACK;\n  }\n  "),(0,p._)("span",{class:"hljs-keyword"},"private"),(0,p.Uk)(" Node "),(0,p._)("span",{class:"hljs-title function_"},"put"),(0,p._)("span",{class:"hljs-params"},"(Node h, Key key, Value val)"),(0,p.Uk)("\n  {\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (h == "),(0,p._)("span",{class:"hljs-literal"},"null"),(0,p.Uk)(") "),(0,p._)("span",{class:"hljs-comment"},"// 标准的插入操作，和父结点用红链接相连"),(0,p.Uk)("\n    "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"new"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-title class_"},"Node"),(0,p.Uk)("(key, val, "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(", RED);\n    "),(0,p._)("span",{class:"hljs-type"},"int"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-variable"},"cmp"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-operator"},"="),(0,p.Uk)(" key.compareTo(h.key);\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp < "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") h.left = put(h.left, key, val);\n    "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (cmp > "),(0,p._)("span",{class:"hljs-number"},"0"),(0,p.Uk)(") h.right = put(h.right, key, val);\n    "),(0,p._)("span",{class:"hljs-keyword"},"else"),(0,p.Uk)(" h.val = val;\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h);\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);\n    "),(0,p._)("span",{class:"hljs-keyword"},"if"),(0,p.Uk)(" (isRed(h.left) && isRed(h.right)) flipColors(h);\n    h.N = size(h.left) + size(h.right) + "),(0,p._)("span",{class:"hljs-number"},"1"),(0,p.Uk)(";\n    "),(0,p._)("span",{class:"hljs-keyword"},"return"),(0,p.Uk)(" h;\n  }\n}\n\n")])])])],-1),ps=[es];function ks(s,l){return(0,p.wg)(),(0,p.iD)("section",null,ps)}const rs={},ts=(0,j.Z)(rs,[["render",ks]]);var cs=ts,_s={components:{RedBlackBSTMd:cs}};const os=(0,j.Z)(_s,[["render",as]]);var hs=os;const is=[{path:"/",component:u},{path:"/sort",component:B},{path:"/priority-queue",component:F},{path:"/bst",component:Y},{path:"/2-3tree",component:ls},{path:"/redBlackBST",component:hs}];var js=is;function Us(s,l,n,a,e,k){const r=(0,p.up)("router-view");return(0,p.wg)(),(0,p.j4)(r)}var us={name:"App",components:{}};const ys=(0,j.Z)(us,[["render",Us]]);var ds=ys;const ms=(0,e.p7)({history:(0,e.r5)(),routes:js}),ws=(0,a.ri)(ds);ws.use(ms),ws.mount("#app")}},l={};function n(a){var e=l[a];if(void 0!==e)return e.exports;var p=l[a]={exports:{}};return s[a](p,p.exports,n),p.exports}n.m=s,function(){var s=[];n.O=function(l,a,e,p){if(!a){var k=1/0;for(_=0;_<s.length;_++){a=s[_][0],e=s[_][1],p=s[_][2];for(var r=!0,t=0;t<a.length;t++)(!1&p||k>=p)&&Object.keys(n.O).every((function(s){return n.O[s](a[t])}))?a.splice(t--,1):(r=!1,p<k&&(k=p));if(r){s.splice(_--,1);var c=e();void 0!==c&&(l=c)}}return l}p=p||0;for(var _=s.length;_>0&&s[_-1][2]>p;_--)s[_]=s[_-1];s[_]=[a,e,p]}}(),function(){n.d=function(s,l){for(var a in l)n.o(l,a)&&!n.o(s,a)&&Object.defineProperty(s,a,{enumerable:!0,get:l[a]})}}(),function(){n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(s){if("object"===typeof window)return window}}()}(),function(){n.o=function(s,l){return Object.prototype.hasOwnProperty.call(s,l)}}(),function(){var s={143:0};n.O.j=function(l){return 0===s[l]};var l=function(l,a){var e,p,k=a[0],r=a[1],t=a[2],c=0;if(k.some((function(l){return 0!==s[l]}))){for(e in r)n.o(r,e)&&(n.m[e]=r[e]);if(t)var _=t(n)}for(l&&l(a);c<k.length;c++)p=k[c],n.o(s,p)&&s[p]&&s[p][0](),s[p]=0;return n.O(_)},a=self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[];a.forEach(l.bind(null,0)),a.push=l.bind(null,a.push.bind(a))}();var a=n.O(void 0,[998],(function(){return n(812)}));a=n.O(a)})();
//# sourceMappingURL=app.9b3667d1.js.map