(function(){"use strict";var s={722:function(s,l,n){var a=n(963),e=n(119),k=n(252);const p=(0,k._)("h2",null,"最近文章",-1),r=(0,k.Uk)("排序"),c=(0,k.Uk)("优先队列"),t=(0,k.Uk)("二叉搜索树");function _(s,l,n,a,e,_){const o=(0,k.up)("router-link");return(0,k.wg)(),(0,k.iD)(k.HY,null,[p,(0,k._)("ul",null,[(0,k._)("li",null,[(0,k.Wm)(o,{to:"/sort"},{default:(0,k.w5)((()=>[r])),_:1})]),(0,k._)("li",null,[(0,k.Wm)(o,{to:"/priority-queue"},{default:(0,k.w5)((()=>[c])),_:1})]),(0,k._)("li",null,[(0,k.Wm)(o,{to:"/bst"},{default:(0,k.w5)((()=>[t])),_:1})])])],64)}var o={name:"About",data(){return{aboutMsg:"我是about组件"}}},h=n(744);const j=(0,h.Z)(o,[["render",_]]);var i=j;const U={class:"markdown-body"};function u(s,l,n,a,e,p){const r=(0,k.up)("SortMd");return(0,k.wg)(),(0,k.iD)("div",U,[(0,k.Wm)(r)])}const y=(0,k._)("html",null,[(0,k._)("head"),(0,k._)("body",null,[(0,k._)("h2",null,"排序"),(0,k._)("h3",null,"归并排序"),(0,k._)("p",null,"归并排序的性能不受输入数据的影响,为稳定排序算法, 速度仅次于快速排序."),(0,k._)("h4",null,"思想"),(0,k._)("p",null,"采用分治法Divide and Conquer）, 分治模式在每一层递归上有三个步骤:"),(0,k._)("ul",null,[(0,k._)("li",null,"分解（Divide）：将n个元素分成个含n/2个元素的子序列。"),(0,k._)("li",null,"解决（Conquer）：用合并排序法对两个子序列递归的排序。"),(0,k._)("li",null,"合并（Combine）：合并两个已排序的子序列已得到排序结果。")]),(0,k._)("h4",null,"实现逻辑(算法第四版 2.2.1):"),(0,k._)("p",null,"先将所有元素复制到aux[], 然后再归并到a[]中. 在归并时,进行4个条件判断:"),(0,k._)("ul",null,[(0,k._)("li",null,[(0,k._)("p",null,"左半边用尽(取右半边元素),")]),(0,k._)("li",null,[(0,k._)("p",null,"右半边用尽(取右半边元素),")]),(0,k._)("li",null,[(0,k._)("p",null,"右半边当前元素小于左半边当前元素(取右半边元素),")]),(0,k._)("li",null,[(0,k._)("p",null,"右半边当前元素小于等于左半边元素(取左半边元素)")])]),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-ts"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"function"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"merge"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("a: Comparable[], lo: "),(0,k._)("span",{class:"hljs-built_in"},"number"),(0,k.Uk)(", mid: "),(0,k._)("span",{class:"hljs-built_in"},"number"),(0,k.Uk)(", hi: "),(0,k._)("span",{class:"hljs-built_in"},"number")]),(0,k.Uk)(") {\n  "),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" i = lo; "),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" j = mid + "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(";\n\n  "),(0,k._)("span",{class:"hljs-keyword"},"const"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-attr"},"aux"),(0,k.Uk)(": "),(0,k._)("span",{class:"hljs-title class_"},"Comparable"),(0,k.Uk)("[] = "),(0,k._)("span",{class:"hljs-title class_"},"Array"),(0,k.Uk)("."),(0,k._)("span",{class:"hljs-title function_"},"from"),(0,k.Uk)("(a);\n\n  "),(0,k._)("span",{class:"hljs-keyword"},"for"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" k = lo; k <= hi; k++) {\n    "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("(i > mid) a[k] = aux[j++];\n    "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("( j > hi) a[k] = aux[i++];\n    "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-title function_"},"less"),(0,k.Uk)("(aux[j], aux[i])) a[k] = aux[j++];\n    "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(" a[k] = a[i++];\n  }\n}\n\n")])]),(0,k._)("h5",null,"递归法(2.2.2)"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-ts"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"function"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"mergeSort"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,k.Uk)(") {\n  "),(0,k._)("span",{class:"hljs-keyword"},"const"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-attr"},"aux"),(0,k.Uk)(": "),(0,k._)("span",{class:"hljs-title class_"},"Comparable"),(0,k.Uk)("[] = [];\n\n  "),(0,k._)("span",{class:"hljs-keyword"},"function"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("array: Comparable[], lo: "),(0,k._)("span",{class:"hljs-built_in"},"number"),(0,k.Uk)(", hi: "),(0,k._)("span",{class:"hljs-built_in"},"number")]),(0,k.Uk)(") {\n    "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("(hi <= lo) "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(";\n    "),(0,k._)("span",{class:"hljs-keyword"},"const"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-attr"},"mid"),(0,k.Uk)(": "),(0,k._)("span",{class:"hljs-built_in"},"number"),(0,k.Uk)(" = lo + (hi - lo) / "),(0,k._)("span",{class:"hljs-number"},"2"),(0,k.Uk)(";\n\n    "),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("(array, lo, mid);\n    "),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("(array, mid + "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(", hi);\n\n    "),(0,k._)("span",{class:"hljs-title function_"},"merge"),(0,k.Uk)("(array, lo, mid , hi);\n  }\n\n  "),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("(arr, "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(" , arr."),(0,k._)("span",{class:"hljs-property"},"length"),(0,k.Uk)(" - "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(");\n\n  "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" arr;\n}\n\n")])]),(0,k._)("h5",null,"迭代法(2.2.3)"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-ts"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"function"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"mergeSort"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,k.Uk)(") {\n  "),(0,k._)("span",{class:"hljs-keyword"},"const"),(0,k.Uk)(" { length } = arr;\n  "),(0,k._)("span",{class:"hljs-keyword"},"const"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-attr"},"aux"),(0,k.Uk)(": "),(0,k._)("span",{class:"hljs-title class_"},"Comparable"),(0,k.Uk)("[] = [];\n\n  "),(0,k._)("span",{class:"hljs-keyword"},"for"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" sz = "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)("; sz < length; sz += sz + sz) { "),(0,k._)("span",{class:"hljs-comment"},"// sz 子数组大小"),(0,k.Uk)("\n    "),(0,k._)("span",{class:"hljs-keyword"},"for"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" lo = "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)("; lo < length - sz; lo += sz + sz) { "),(0,k._)("span",{class:"hljs-comment"},"// 子数组索引"),(0,k.Uk)("\n      "),(0,k._)("span",{class:"hljs-title function_"},"merge"),(0,k.Uk)("(arr, lo, lo + sz - "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(", "),(0,k._)("span",{class:"hljs-title class_"},"Math"),(0,k.Uk)("."),(0,k._)("span",{class:"hljs-title function_"},"min"),(0,k.Uk)("(lo + sz + sz - "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(", length -"),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)("))\n    }\n  }\n\n}\n\n")])]),(0,k._)("p",null,"不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )"),(0,k._)("p",null,"空间复杂度为: O(n)。"),(0,k._)("h3",null,"快速排序"),(0,k._)("p",null,"快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-ts"},[(0,k.Uk)("\n  "),(0,k._)("span",{class:"hljs-keyword"},"function"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"quickSort"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,k.Uk)(") {\n    "),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("(arr, "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(", arr."),(0,k._)("span",{class:"hljs-property"},"lenght"),(0,k.Uk)(" - "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(");\n\n    "),(0,k._)("span",{class:"hljs-keyword"},"function"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-params"},"array: Comparable[], lo, hi"),(0,k.Uk)(") {\n      "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("(hi <= lo) "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(";\n\n      "),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" j = "),(0,k._)("span",{class:"hljs-title function_"},"partition"),(0,k.Uk)("(array, lo, hi); "),(0,k._)("span",{class:"hljs-comment"},"// 切分"),(0,k.Uk)("\n\n      "),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("(array, lo, j - "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(");\n      "),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k.Uk)("(array, j + "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(", hi);\n    }\n\n    "),(0,k._)("span",{class:"hljs-keyword"},"function"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"partition"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-params"},"array: Comparable[], lo , hi"),(0,k.Uk)(") {\n      "),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" i = lo; "),(0,k._)("span",{class:"hljs-keyword"},"let"),(0,k.Uk)(" j = hi + "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(";\n\n      "),(0,k._)("span",{class:"hljs-keyword"},"const"),(0,k.Uk)(" v = array[lo];\n\n      "),(0,k._)("span",{class:"hljs-keyword"},"while"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-literal"},"true"),(0,k.Uk)(") {\n        "),(0,k._)("span",{class:"hljs-keyword"},"while"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-title function_"},"less"),(0,k.Uk)("(array[++i], v)) "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("(i == hi) "),(0,k._)("span",{class:"hljs-keyword"},"break"),(0,k.Uk)(";\n        "),(0,k._)("span",{class:"hljs-keyword"},"while"),(0,k.Uk)("("),(0,k._)("span",{class:"hljs-title function_"},"less"),(0,k.Uk)("(v, arry[--j])) "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("(j == lo) "),(0,k._)("span",{class:"hljs-keyword"},"break"),(0,k.Uk)(";\n\n        "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("(j <= i ) "),(0,k._)("span",{class:"hljs-keyword"},"break"),(0,k.Uk)(";\n        "),(0,k._)("span",{class:"hljs-title function_"},"exch"),(0,k.Uk)("(array, i, j);\n      }\n\n      "),(0,k._)("span",{class:"hljs-title function_"},"exch"),(0,k.Uk)("(array, lo, j);\n\n      "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" j;\n\n    }\n  }\n\n")])]),(0,k._)("p",null,[(0,k.Uk)("快速排序的平均时间复杂度是 O(nlogn), 但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 O(n2) "),(0,k._)("strong",null,"(即已经排序好的数组))"),(0,k.Uk)(" , 所以开始可以先打乱数组的顺序保持随机性.而且对于小数组,其实快速排序比插入排序慢;所以可以混合使用;")]),(0,k._)("p",null,"快速排序只是使用数组原本的空间进行排序;"),(0,k._)("p",null,"快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。"),(0,k._)("p",null,"快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。"),(0,k._)("h3",null,"堆排序"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"static"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"sort"),(0,k._)("span",{class:"hljs-params"},"(Comparable[] a)"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"N"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" a.length;\n   "),(0,k._)("span",{class:"hljs-keyword"},"for"),(0,k.Uk)(" ("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"k"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" N/"),(0,k._)("span",{class:"hljs-number"},"2"),(0,k.Uk)("; k >= "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)("; k--)\n      sink(a, k, N);\n   "),(0,k._)("span",{class:"hljs-keyword"},"while"),(0,k.Uk)(" (N > "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(")\n   {\n      exch(a, "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(", N--);\n      sink(a, "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(", N);\n   }\n}\n")])]),(0,k._)("p",null,[(0,k.Uk)("以上代码中,第一个循环,构造了一个二叉堆, 第二个循环,依次将堆顶元素和最后一个元素交换,并通过缩小数组N的值来弹出原堆顶 "),(0,k._)("strong",null,"(最值)"),(0,k.Uk)(" 缩小堆的大小.")]),(0,k._)("p",null,[(0,k.Uk)("在前面文章 "),(0,k._)("strong",null,"(优先队列)"),(0,k.Uk)(" 里介绍过的,由数组构造的二叉堆中,父节点位置为"),(0,k._)("strong",null,"k"),(0,k.Uk)("时,子节点分别为"),(0,k._)("strong",null,"2k"),(0,k.Uk)("和"),(0,k._)("strong",null,"2k+1"),(0,k.Uk)(",所以从 "),(0,k._)("strong",null,"N/2"),(0,k.Uk)("的位置找到最大的父节点,并依次"),(0,k._)("strong",null,"sink"),(0,k.Uk)("操作(sink操作见优先队列),从而达到堆有序.")]),(0,k._)("p",null,"如下图:"),(0,k._)("p",null,[(0,k._)("img",{src:"'/assets/%E5%A0%86%E6%8E%92%E5%BA%8F.png'",alt:"堆排序"})])])],-1),d=[y];function m(s,l){return(0,k.wg)(),(0,k.iD)("section",null,d)}const w={},f=(0,h.Z)(w,[["render",m]]);var b=f,v=(n(29),{name:"Sort",components:{SortMd:b}});const g=(0,h.Z)(v,[["render",u]]);var x=g;const N={class:"markdown-body"};function q(s,l,n,a,e,p){const r=(0,k.up)("PriorityQueueMd");return(0,k.wg)(),(0,k.iD)("div",N,[(0,k.Wm)(r)])}const K=(0,k._)("html",null,[(0,k._)("head"),(0,k._)("body",null,[(0,k._)("h2",null,"优先队列 (算法第四版2.4)"),(0,k._)("p",null,"普通队列是一种先进先出的数据结构，先放进队列的元素取值时优先被取出来。而优先队列是一种具有最高优先级元素先出的数据结构，比如每次取值都取最大的元素, 它包含最重要的两种操作: 删除最大元素delMax和插入元素insert()."),(0,k._)("h3",null,"堆的定义"),(0,k._)("p",null,"当一颗二叉树的每个节点都大于等于它的两个子节点时,它被称为堆有序, 所以根节点是堆有序的二叉树中的最大节点"),(0,k._)("h3",null,"二叉堆表示法"),(0,k._)("h4",null,"完全二叉树的定义"),(0,k._)("p",null,"二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）"),(0,k._)("h4",null,"数组表示完全二叉树"),(0,k._)("p",null,"如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）. 如果我们使用完全二叉树，表达就会变得特别方便"),(0,k._)("p",null,[(0,k.Uk)("完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。 "),(0,k._)("strong",null,"（不使用数组的第一个位置, 哨兵）")]),(0,k._)("p",null,[(0,k._)("strong",null,"简单起见，在下文中我们将二叉堆简称为堆）"),(0,k.Uk)(" 在一个堆中，位置 "),(0,k._)("strong",null,"k"),(0,k.Uk)(" 的结点的父结点的位置为 "),(0,k._)("strong",null,"k / 2"),(0,k.Uk)("而它的两个子结点的位置则分别为 "),(0,k._)("strong",null,"2k"),(0,k.Uk)(" 和 "),(0,k._)("strong",null,"2k+1"),(0,k.Uk)("。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1。")]),(0,k._)("blockquote",null,[(0,k._)("p",null,[(0,k._)("strong",null,"命题 P"),(0,k.Uk)("。一棵大小为 "),(0,k._)("strong",null,"N"),(0,k.Uk)(" 的完全二叉树的高度为 "),(0,k._)("strong",null,"lgN"),(0,k.Uk)("。")])]),(0,k._)("blockquote",null,[(0,k._)("p",null,[(0,k._)("strong",null,"证明"),(0,k.Uk)("。通过归纳很容易可以证明这一点，且当 达到 2 的幂时树的高度会加 1。")])]),(0,k._)("h3",null,"堆的算法"),(0,k._)("p",null,[(0,k.Uk)("我们用长度为 "),(0,k._)("strong",null,"k + 1"),(0,k.Uk)(" 的私有数组 pq[] 来表示一个大小为 "),(0,k._)("strong",null,"k"),(0,k.Uk)(" 的堆，我们不会使用 pq[0]，堆元素放在 pq[1] 至 pq[N] 中")]),(0,k._)("h4",null,"堆实现的比较和交换方法"),(0,k._)("p",null,"因为所有的元素都在数组 pq[] 中，不再将数组作为参数传递"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"boolean"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"less"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" i, "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" j)")]),(0,k.Uk)("\n{  "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" pq[i].compareTo(pq[j]) < "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(";  }\n\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"exch"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" i, "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" j)")]),(0,k.Uk)("\n{  "),(0,k._)("span",{class:"hljs-type"},"Key"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"t"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" pq[i]; pq[i] = pq[j]; pq[j] = t;  }\n\n")])]),(0,k._)("h4",null,"由下自上的堆有序化（上浮）"),(0,k._)("p",null,"当调用优先队列的insert方法时，我们首先把元素放置到数组的结尾，然后再把该元素上浮到正确的节点，最终形成堆有序状态。"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"swim"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" k)")]),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"while"),(0,k.Uk)(" (k > "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(" && less(k/"),(0,k._)("span",{class:"hljs-number"},"2"),(0,k.Uk)(", k))\n   {\n      exch(k/"),(0,k._)("span",{class:"hljs-number"},"2"),(0,k.Uk)(", k);\n      k = k/"),(0,k._)("span",{class:"hljs-number"},"2"),(0,k.Uk)(";\n   }\n}\n\n\n")])]),(0,k._)("h4",null,"由上至下的堆有序化（下沉）"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"sink"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" k)")]),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"while"),(0,k.Uk)(" ("),(0,k._)("span",{class:"hljs-number"},"2"),(0,k.Uk)("*k <= N)\n   {\n      "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"j"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(),(0,k._)("span",{class:"hljs-number"},"2"),(0,k.Uk)("*k;\n      "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (j < N && less(j, j+"),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(")) j++;\n      "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (!less(k, j)) "),(0,k._)("span",{class:"hljs-keyword"},"break"),(0,k.Uk)(";\n      exch(k, j);\n      k = j;\n   }\n}\n\n")])]),(0,k._)("p",null,[(0,k._)("img",{src:"'../assets/%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C.png'",alt:"堆的操作"})]),(0,k._)("h4"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"class"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title class_"},"MaxPQ"),(0,k.Uk)("<Key "),(0,k._)("span",{class:"hljs-keyword"},"extends"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title class_"},"Comparable"),(0,k.Uk)("<Key>>\n{\n  "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Key[] pq;             "),(0,k._)("span",{class:"hljs-comment"},"// 基于堆的完全按二叉树”"),(0,k.Uk)("\n  "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"N"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(";            "),(0,k._)("span",{class:"hljs-comment"},"// 存储于pq[1..N]中，pq[0]没有使用"),(0,k.Uk)("\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"MaxPQ"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" maxN)")]),(0,k.Uk)("\n   {  pq = (Key[]) "),(0,k._)("span",{class:"hljs-keyword"},"new"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title class_"},"Comparable"),(0,k.Uk)("[maxN+"),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)("];  }\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"boolean"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"isEmpty"),(0,k._)("span",{class:"hljs-params"},"()"),(0,k.Uk)("\n   {  "),(0,k._)("span",{class:"hljs-type"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"N"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)("= "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(";  }\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"size"),(0,k._)("span",{class:"hljs-params"},"()"),(0,k.Uk)("\n   {  "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" N;  }\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"insert"),(0,k._)("span",{class:"hljs-params"},"(Key v)"),(0,k.Uk)("\n   {\n      pq[++N] = v;\n      swim(N);\n   }\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(" Key "),(0,k._)("span",{class:"hljs-title function_"},"delMax"),(0,k._)("span",{class:"hljs-params"},"()"),(0,k.Uk)("\n   {\n      "),(0,k._)("span",{class:"hljs-type"},"Key"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"max"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" pq["),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)("];           "),(0,k._)("span",{class:"hljs-comment"},"// 从根结点得到最大元素"),(0,k.Uk)("\n      exch("),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(", N--);              "),(0,k._)("span",{class:"hljs-comment"},"// 将其和最后一个结点交换"),(0,k.Uk)("\n      pq[N+"),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)("] = "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(";            "),(0,k._)("span",{class:"hljs-comment"},"// 防止对象游离"),(0,k.Uk)("\n      sink("),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(");                   "),(0,k._)("span",{class:"hljs-comment"},"// 恢复堆的有序性"),(0,k.Uk)("\n      "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" max;\n   }\n\n   "),(0,k._)("span",{class:"hljs-comment"},"// 辅助方法的实现请见本节前面的代码框"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"boolean"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"less"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" i, "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" j)")]),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"exch"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" i, "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" j)")]),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"swim"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" k)")]),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"sink"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" k)")]),(0,k.Uk)("\n}\n\n")])]),(0,k._)("p",null,"优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。在 insert() 中，我们将 N 加一并把新元素添加在数组最后，然后用 swim() 恢复堆的秩序。在 delMax() 中，我们从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink() 恢复堆的秩序。同时我们还将不再使用的 pq[N+1] 设为 null，以便系统回收它所占用的空间。这里省略了动态调整数组大小的代码"),(0,k._)("blockquote",null,[(0,k._)("p",null,[(0,k._)("strong",null,"命题 Q"),(0,k.Uk)("。对于一个含有 "),(0,k._)("strong",null,"N"),(0,k.Uk)(" 个元素的基于堆的优先队列，插入元素操作只需不超过（"),(0,k._)("strong",null,"lgN + 1"),(0,k.Uk)("）次比较，删除最大元素的操作需要不超过 "),(0,k._)("strong",null,"2lgN"),(0,k.Uk)(" 次比较。")])]),(0,k._)("blockquote",null,[(0,k._)("p",null,[(0,k._)("strong",null,"证明"),(0,k.Uk)("。由命题 P 可知，两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过 "),(0,k._)("strong",null,"lgN"),(0,k.Uk)("。对于路径上的每个结点，删除最大元素需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。")])])])],-1),z=[K];function M(s,l){return(0,k.wg)(),(0,k.iD)("section",null,z)}const C={},O=(0,h.Z)(C,[["render",M]]);var D=O,T={name:"PriorityQueue",components:{PriorityQueueMd:D}};const E=(0,h.Z)(T,[["render",q]]);var P=E;const V={class:"markdown-body"};function S(s,l,n,a,e,p){const r=(0,k.up)("BstMd");return(0,k.wg)(),(0,k.iD)("div",V,[(0,k.Wm)(r)])}const Z=(0,k._)("html",null,[(0,k._)("head"),(0,k._)("body",null,[(0,k._)("h2",null,"二叉搜索树"),(0,k._)("h3",null,"定义"),(0,k._)("p",null,"一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键."),(0,k._)("p",null,"每一个二叉搜索树的左右子树也都是一个二叉搜索树"),(0,k._)("p",null,"二叉搜索树如果用中序遍历一下，就是一个从大到小的序列"),(0,k._)("h3",null,"二叉查找树的建立"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"class"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title class_"},"BST"),(0,k.Uk)("<Key "),(0,k._)("span",{class:"hljs-keyword"},"extends"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title class_"},"Comparable"),(0,k.Uk)("<Key>, Value>\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node root;               "),(0,k._)("span",{class:"hljs-comment"},"// 二叉查找树的根结点"),(0,k.Uk)("\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"class"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title class_"},"Node"),(0,k.Uk)("\n   {\n      "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Key key;              "),(0,k._)("span",{class:"hljs-comment"},"// 键"),(0,k.Uk)("\n      "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Value val;            "),(0,k._)("span",{class:"hljs-comment"},"// 值"),(0,k.Uk)("\n      "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node left, right;     "),(0,k._)("span",{class:"hljs-comment"},"// 指向子树的链接"),(0,k.Uk)("\n      "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" N;                "),(0,k._)("span",{class:"hljs-comment"},"// 以该结点为根的子树中的结点总数"),(0,k.Uk)("\n\n      "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"Node"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("(Key key, Value val, "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" N)")]),(0,k.Uk)("\n      {  "),(0,k._)("span",{class:"hljs-built_in"},"this"),(0,k.Uk)(".key = key; "),(0,k._)("span",{class:"hljs-built_in"},"this"),(0,k.Uk)(".val = val; "),(0,k._)("span",{class:"hljs-built_in"},"this"),(0,k.Uk)(".N = N; }\n   }\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"size"),(0,k._)("span",{class:"hljs-params"},"()"),(0,k.Uk)("\n   {  "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" size(root);  }\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"size"),(0,k._)("span",{class:"hljs-params"},"(Node x)"),(0,k.Uk)("\n   {\n      "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(";\n      "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)("           "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x.N;\n   }\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(" Value "),(0,k._)("span",{class:"hljs-title function_"},"get"),(0,k._)("span",{class:"hljs-params"},"(Key key)"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-comment"},"// 请见算法3.3（续1）"),(0,k.Uk)("\n\n   "),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"put"),(0,k._)("span",{class:"hljs-params"},"(Key key, Value val)"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-comment"},"// 请见算法3.3（续1）"),(0,k.Uk)("\n\n   "),(0,k._)("span",{class:"hljs-comment"},"// max()、min()、floor()、ceiling()方法请见算法3.3（续2）"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-comment"},"// select()、rank()方法请见算法3.3（续3）"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-comment"},"// delete()、deleteMin()、deleteMax()方法请见算法3.3（续4）"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-comment"},"// keys()方法请见算法3.3（续5）"),(0,k.Uk)("\n}\n\n")])]),(0,k._)("h3",null,"算法 3.3（续 1）二叉查找树的查找和赋值"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-comment"},"/*查找*/"),(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(" Value "),(0,k._)("span",{class:"hljs-title function_"},"get"),(0,k._)("span",{class:"hljs-params"},"(Key key)"),(0,k.Uk)("\n{  "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" get(root, key);  }\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Value "),(0,k._)("span",{class:"hljs-title function_"},"get"),(0,k._)("span",{class:"hljs-params"},"(Node x, Key key)"),(0,k.Uk)("\n{  "),(0,k._)("span",{class:"hljs-comment"},"// 在以x为根结点的子树中查找并返回key所对应的值；"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-comment"},"// 如果找不到则返回null"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"cmp"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" key.compareTo(x.key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("      (cmp < "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" get(x.left, key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (cmp > "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" get(x.right, key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x.val;\n}\n"),(0,k._)("span",{class:"hljs-comment"},"/*赋值*/"),(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"put"),(0,k._)("span",{class:"hljs-params"},"(Key key, Value val)"),(0,k.Uk)("\n{  "),(0,k._)("span",{class:"hljs-comment"},"// 查找key，找到则更新它的值，否则为它创建一个新的结点"),(0,k.Uk)("\n   root = put(root, key, val);\n}\n\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node "),(0,k._)("span",{class:"hljs-title function_"},"put"),(0,k._)("span",{class:"hljs-params"},"(Node x, Key key, Value val)"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-comment"},"// 如果key存在于以x为根结点的子树中则更新它的值；"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-comment"},"// 否则将以key和val为键值对的新结点插入到该子树中"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"new"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title class_"},"Node"),(0,k.Uk)("(key, val, "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(");\n   "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"cmp"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" key.compareTo(x.key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("      (cmp < "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") x.left  = put(x.left,  key, val);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (cmp > "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") x.right = put(x.right, key, val);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(" x.val = val;\n   x.N = size(x.left) + size(x.right) + "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x;\n}\n\n")])]),(0,k._)("h3",null,"分析二叉查找树查找节点的时间复杂度(节点数为N)"),(0,k._)("p",null,"最差情况下,二叉查找树退化成链表,树高等于节点也为N"),(0,k._)("p",null,[(0,k.Uk)("理想情况下,一颗含有N个节点的二叉查找树是完全平衡的,他的树高为 "),(0,k._)("strong",null,"lgN")]),(0,k._)("p",null,[(0,k.Uk)("二叉查找树的查找的平均时间复杂度为~2InN,约为"),(0,k._)("strong",null,"1.39lgN"),(0,k.Uk)(",比二分查找的成本高约"),(0,k._)("strong",null,"39%")]),(0,k._)("h3",null,"最大键最小键 及 向上取整和向下取整"),(0,k._)("h4",null,"最大键最小键"),(0,k._)("p",null,"如果根节点左链接为空为空,则一颗二叉查找树的最小节点是根节点.如果左子树非空,那么树中最小键也是左子树的最小键."),(0,k._)("p",null,"最大键相反"),(0,k._)("h4",null,"向上取整和向下取整"),(0,k._)("p",null,[(0,k.Uk)("如果给定的键key小于二叉查找树根节点,那么"),(0,k._)("strong",null,"小于等于"),(0,k.Uk)("key的最大键**floor(key)**一定在根节点的左子树中;如果给定的键key大于二叉查找树的根节点,只有当根节点的右节点存在小于等于key的节点,小于等于key的最大键才会存在于右子树中,否则根节点就是小于等于key的最大键")]),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(" Key "),(0,k._)("span",{class:"hljs-title function_"},"min"),(0,k._)("span",{class:"hljs-params"},"()"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" min(root).key;\n}\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node "),(0,k._)("span",{class:"hljs-title function_"},"min"),(0,k._)("span",{class:"hljs-params"},"(Node x)"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x.left == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x;\n   "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" min(x.left);\n}\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(" Key "),(0,k._)("span",{class:"hljs-title function_"},"floor"),(0,k._)("span",{class:"hljs-params"},"(Key key)"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-type"},"Node"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"x"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" floor(root, key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x.key;\n}\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node "),(0,k._)("span",{class:"hljs-title function_"},"floor"),(0,k._)("span",{class:"hljs-params"},"(Node x, Key key)"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"cmp"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" key.compareTo(x.key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (cmp == "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x;\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (cmp < "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(")  "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" floor(x.left, key);\n   "),(0,k._)("span",{class:"hljs-type"},"Node"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"t"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" floor(x.right, key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (t != "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" t;\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)("           "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x;\n}\n\n")])]),(0,k._)("h3",null,"排名"),(0,k._)("h4",null,"select()"),(0,k._)("p",null,"假设我们想找到排名为 的键（即树中正好有 个小于它的键）。如果左子树中的结点数 大于 ，那么我们就继续（递归地）在左子树中查找排名为 的键；如果 等于 ，我们就返回根结点中的键；如果 小于 ，我们就（递归地）在右子树中查找排名为（）的键。"),(0,k._)("h4",null,"rank()"),(0,k._)("p",null,"rank() 是 select() 的逆方法，它会返回给定键的排名。它的实现和 select() 类似：如果给定的键和根结点的键相等，我们返回左子树中的结点总数 ；如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）；如果给定的键大于根结点，我们会返回 （根结点）加上它在右子树中的排名（递归计算）"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(" Key "),(0,k._)("span",{class:"hljs-title function_"},"select"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("("),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" k)")]),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" select(root, k).key;\n}\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node "),(0,k._)("span",{class:"hljs-title function_"},"select"),(0,k._)("span",{class:"hljs-params"},[(0,k.Uk)("(Node x, "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(" k)")]),(0,k.Uk)("\n{   "),(0,k._)("span",{class:"hljs-comment"},"// 返回排名为k的结点"),(0,k.Uk)("\n    "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(";\n    "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"t"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" size(x.left);\n    "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("      (t > k) "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" select(x.left,  k);\n    "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (t < k) "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" select(x.right, k-t-"),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(");\n    "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)("            "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x;\n}\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"rank"),(0,k._)("span",{class:"hljs-params"},"(Key key)"),(0,k.Uk)("\n{  "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" rank(key, root);  }\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"rank"),(0,k._)("span",{class:"hljs-params"},"(Key key, Node x)"),(0,k.Uk)("\n{  "),(0,k._)("span",{class:"hljs-comment"},"// 返回以x为根结点的子树中小于x.key的键的数量"),(0,k.Uk)("\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"cmp"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" key.compareTo(x.key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("      (cmp < "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" rank(key, x.left);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (cmp > "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(" + size(x.left) + rank(key, x.right);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)("              "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" size(x.left);\n}\n\n")])]),(0,k._)("h3",null,"删除delete()"),(0,k._)("h4",null,"删除最大最小键"),(0,k._)("p",null,[(0,k.Uk)("二叉查找树中最难实现的方法就是 "),(0,k._)("strong",null,"delete()"),(0,k.Uk)(" 方法，即从符号表中删除一个键值对”, 在此之前我们先考虑 "),(0,k._)("strong",null,"deleteMin()"),(0,k.Uk)(" 方法")]),(0,k._)("p",null,"和 put() 一样，我们的递归方法接受一个指向结点的链接，并返回一个指向结点的链接。这样我们就能够方便地改变树的结构，将返回的链接赋给作为参数的链接。对于 deleteMin()，我们要不断深入根结点的左子树中直至遇见一个空链接，然后将指向该结点的链接指向该结点的右子树（只需要在递归调用中返回它的右链接即可）。此时已经没有任何链接指向要被删除的结点，因此它会被垃圾收集器清理掉. deleteMax() 方法的实现和 deleteMin() 完全类似。"),(0,k._)("h4",null,"删除操作"),(0,k._)("p",null,"我们可以用类似的方式删除任意只有一个子结点（或者没有子结点）的结点，但应该怎样删除一个拥有两个子结点的结点呢？"),(0,k._)("p",null,"删除之后我们要处理两棵子树，但被删除结点的父结点只有一条空出来的链接。T. Hibbard 在 1962 年提出了解决这个难题的第一个方法，在删除结点 x 后用它的后继结点填补它的位置。因为 x 有一个右子结点，因此它的后继结点就是其右子树中的最小结点。这样的替换仍然能够保证树的有序性，因为 x.key 和它的后继结点的键之间不存在其他的键"),(0,k._)("pre",null,[(0,k._)("code",{"v-pre":"",class:"language-java"},[(0,k.Uk)("\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"deleteMin"),(0,k._)("span",{class:"hljs-params"},"()"),(0,k.Uk)("\n{\n   root = deleteMin(root);\n}\n\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node "),(0,k._)("span",{class:"hljs-title function_"},"deleteMin"),(0,k._)("span",{class:"hljs-params"},"(Node x)"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x.left == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x.right;\n   x.left = deleteMin(x.left);\n   x.N = size(x.left) + size(x.right) + "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x;\n   }\n\n"),(0,k._)("span",{class:"hljs-keyword"},"public"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"void"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-title function_"},"delete"),(0,k._)("span",{class:"hljs-params"},"(Key key)"),(0,k.Uk)("\n{  root = delete(root, key);  }\n\n"),(0,k._)("span",{class:"hljs-keyword"},"private"),(0,k.Uk)(" Node "),(0,k._)("span",{class:"hljs-title function_"},"delete"),(0,k._)("span",{class:"hljs-params"},"(Node x, Key key)"),(0,k.Uk)("\n{\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-type"},"int"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"cmp"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" key.compareTo(x.key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)("      (cmp < "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") x.left  = delete(x.left,  key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (cmp > "),(0,k._)("span",{class:"hljs-number"},"0"),(0,k.Uk)(") x.right = delete(x.right, key);\n   "),(0,k._)("span",{class:"hljs-keyword"},"else"),(0,k.Uk)("\n   {\n      "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x.right == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x.left;\n      "),(0,k._)("span",{class:"hljs-keyword"},"if"),(0,k.Uk)(" (x.left == "),(0,k._)("span",{class:"hljs-literal"},"null"),(0,k.Uk)(") "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x.right;\n      "),(0,k._)("span",{class:"hljs-type"},"Node"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-variable"},"t"),(0,k.Uk)(),(0,k._)("span",{class:"hljs-operator"},"="),(0,k.Uk)(" x;\n      x = min(t.right);  "),(0,k._)("span",{class:"hljs-comment"},"// 请见算法3.3（续2）"),(0,k.Uk)("\n      x.right = deleteMin(t.right);\n      x.left = t.left;\n   }\n   x.N = size(x.left) + size(x.right) + "),(0,k._)("span",{class:"hljs-number"},"1"),(0,k.Uk)(";\n   "),(0,k._)("span",{class:"hljs-keyword"},"return"),(0,k.Uk)(" x;\n}\n\n")])])])],-1),A=[Z];function B(s,l){return(0,k.wg)(),(0,k.iD)("section",null,A)}const Q={},W=(0,h.Z)(Q,[["render",B]]);var F=W,H={name:"Bst",components:{BstMd:F}};const I=(0,h.Z)(H,[["render",S]]);var Y=I;const G=[{path:"/",component:i},{path:"/sort",component:x},{path:"/priority-queue",component:P},{path:"/bst",component:Y}];var J=G;function L(s,l,n,a,e,p){const r=(0,k.up)("router-view");return(0,k.wg)(),(0,k.j4)(r)}var R={name:"App",components:{}};const X=(0,h.Z)(R,[["render",L]]);var $=X;const ss=(0,e.p7)({history:(0,e.r5)(),routes:J}),ls=(0,a.ri)($);ls.use(ss),ls.mount("#app")}},l={};function n(a){var e=l[a];if(void 0!==e)return e.exports;var k=l[a]={exports:{}};return s[a](k,k.exports,n),k.exports}n.m=s,function(){var s=[];n.O=function(l,a,e,k){if(!a){var p=1/0;for(_=0;_<s.length;_++){a=s[_][0],e=s[_][1],k=s[_][2];for(var r=!0,c=0;c<a.length;c++)(!1&k||p>=k)&&Object.keys(n.O).every((function(s){return n.O[s](a[c])}))?a.splice(c--,1):(r=!1,k<p&&(p=k));if(r){s.splice(_--,1);var t=e();void 0!==t&&(l=t)}}return l}k=k||0;for(var _=s.length;_>0&&s[_-1][2]>k;_--)s[_]=s[_-1];s[_]=[a,e,k]}}(),function(){n.d=function(s,l){for(var a in l)n.o(l,a)&&!n.o(s,a)&&Object.defineProperty(s,a,{enumerable:!0,get:l[a]})}}(),function(){n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(s){if("object"===typeof window)return window}}()}(),function(){n.o=function(s,l){return Object.prototype.hasOwnProperty.call(s,l)}}(),function(){var s={143:0};n.O.j=function(l){return 0===s[l]};var l=function(l,a){var e,k,p=a[0],r=a[1],c=a[2],t=0;if(p.some((function(l){return 0!==s[l]}))){for(e in r)n.o(r,e)&&(n.m[e]=r[e]);if(c)var _=c(n)}for(l&&l(a);t<p.length;t++)k=p[t],n.o(s,k)&&s[k]&&s[k][0](),s[k]=0;return n.O(_)},a=self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[];a.forEach(l.bind(null,0)),a.push=l.bind(null,a.push.bind(a))}();var a=n.O(void 0,[998],(function(){return n(722)}));a=n.O(a)})();
//# sourceMappingURL=app.41fbd46b.js.map