(function(){"use strict";var s={510:function(s,l,n){var a=n(963),e=n(119),r=n(252);const p=(0,r._)("h2",null,"最近文章",-1),t=(0,r.Uk)("排序"),k=(0,r.Uk)("优先队列");function c(s,l,n,a,e,c){const _=(0,r.up)("router-link");return(0,r.wg)(),(0,r.iD)(r.HY,null,[p,(0,r._)("ul",null,[(0,r._)("li",null,[(0,r.Wm)(_,{to:"/sort"},{default:(0,r.w5)((()=>[t])),_:1})]),(0,r._)("li",null,[(0,r.Wm)(_,{to:"/priority-queue"},{default:(0,r.w5)((()=>[k])),_:1})])])],64)}var _={name:"About",data(){return{aboutMsg:"我是about组件"}}},o=n(744);const h=(0,o.Z)(_,[["render",c]]);var u=h;const i={class:"markdown-body"};function j(s,l,n,a,e,p){const t=(0,r.up)("SortMd");return(0,r.wg)(),(0,r.iD)("div",i,[(0,r.Wm)(t)])}const U=(0,r._)("html",null,[(0,r._)("head"),(0,r._)("body",null,[(0,r._)("h2",null,"排序"),(0,r._)("h3",null,"归并排序"),(0,r._)("p",null,"归并排序的性能不受输入数据的影响,为稳定排序算法, 速度仅次于快速排序."),(0,r._)("h4",null,"思想"),(0,r._)("p",null,"采用分治法Divide and Conquer）, 分治模式在每一层递归上有三个步骤:"),(0,r._)("ul",null,[(0,r._)("li",null,"分解（Divide）：将n个元素分成个含n/2个元素的子序列。"),(0,r._)("li",null,"解决（Conquer）：用合并排序法对两个子序列递归的排序。"),(0,r._)("li",null,"合并（Combine）：合并两个已排序的子序列已得到排序结果。")]),(0,r._)("h4",null,"实现逻辑(算法第四版 2.2.1):"),(0,r._)("p",null,"先将所有元素复制到aux[], 然后再归并到a[]中. 在归并时,进行4个条件判断:"),(0,r._)("ul",null,[(0,r._)("li",null,[(0,r._)("p",null,"左半边用尽(取右半边元素),")]),(0,r._)("li",null,[(0,r._)("p",null,"右半边用尽(取右半边元素),")]),(0,r._)("li",null,[(0,r._)("p",null,"右半边当前元素小于左半边当前元素(取右半边元素),")]),(0,r._)("li",null,[(0,r._)("p",null,"右半边当前元素小于等于左半边元素(取左半边元素)")])]),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-ts"},[(0,r.Uk)("\n"),(0,r._)("span",{class:"hljs-keyword"},"function"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"merge"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("a: Comparable[], lo: "),(0,r._)("span",{class:"hljs-built_in"},"number"),(0,r.Uk)(", mid: "),(0,r._)("span",{class:"hljs-built_in"},"number"),(0,r.Uk)(", hi: "),(0,r._)("span",{class:"hljs-built_in"},"number")]),(0,r.Uk)(") {\n  "),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" i = lo; "),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" j = mid + "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(";\n\n  "),(0,r._)("span",{class:"hljs-keyword"},"const"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-attr"},"aux"),(0,r.Uk)(": "),(0,r._)("span",{class:"hljs-title class_"},"Comparable"),(0,r.Uk)("[] = "),(0,r._)("span",{class:"hljs-title class_"},"Array"),(0,r.Uk)("."),(0,r._)("span",{class:"hljs-title function_"},"from"),(0,r.Uk)("(a);\n\n  "),(0,r._)("span",{class:"hljs-keyword"},"for"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" k = lo; k <= hi; k++) {\n    "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("(i > mid) a[k] = aux[j++];\n    "),(0,r._)("span",{class:"hljs-keyword"},"else"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("( j > hi) a[k] = aux[i++];\n    "),(0,r._)("span",{class:"hljs-keyword"},"else"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-title function_"},"less"),(0,r.Uk)("(aux[j], aux[i])) a[k] = aux[j++];\n    "),(0,r._)("span",{class:"hljs-keyword"},"else"),(0,r.Uk)(" a[k] = a[i++];\n  }\n}\n\n")])]),(0,r._)("h5",null,"递归法(2.2.2)"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-ts"},[(0,r.Uk)("\n"),(0,r._)("span",{class:"hljs-keyword"},"function"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"mergeSort"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,r.Uk)(") {\n  "),(0,r._)("span",{class:"hljs-keyword"},"const"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-attr"},"aux"),(0,r.Uk)(": "),(0,r._)("span",{class:"hljs-title class_"},"Comparable"),(0,r.Uk)("[] = [];\n\n  "),(0,r._)("span",{class:"hljs-keyword"},"function"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("array: Comparable[], lo: "),(0,r._)("span",{class:"hljs-built_in"},"number"),(0,r.Uk)(", hi: "),(0,r._)("span",{class:"hljs-built_in"},"number")]),(0,r.Uk)(") {\n    "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("(hi <= lo) "),(0,r._)("span",{class:"hljs-keyword"},"return"),(0,r.Uk)(";\n    "),(0,r._)("span",{class:"hljs-keyword"},"const"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-attr"},"mid"),(0,r.Uk)(": "),(0,r._)("span",{class:"hljs-built_in"},"number"),(0,r.Uk)(" = lo + (hi - lo) / "),(0,r._)("span",{class:"hljs-number"},"2"),(0,r.Uk)(";\n\n    "),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("(array, lo, mid);\n    "),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("(array, mid + "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(", hi);\n\n    "),(0,r._)("span",{class:"hljs-title function_"},"merge"),(0,r.Uk)("(array, lo, mid , hi);\n  }\n\n  "),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("(arr, "),(0,r._)("span",{class:"hljs-number"},"0"),(0,r.Uk)(" , arr."),(0,r._)("span",{class:"hljs-property"},"length"),(0,r.Uk)(" - "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(");\n\n  "),(0,r._)("span",{class:"hljs-keyword"},"return"),(0,r.Uk)(" arr;\n}\n\n")])]),(0,r._)("h5",null,"迭代法(2.2.3)"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-ts"},[(0,r.Uk)("\n"),(0,r._)("span",{class:"hljs-keyword"},"function"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"mergeSort"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,r.Uk)(") {\n  "),(0,r._)("span",{class:"hljs-keyword"},"const"),(0,r.Uk)(" { length } = arr;\n  "),(0,r._)("span",{class:"hljs-keyword"},"const"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-attr"},"aux"),(0,r.Uk)(": "),(0,r._)("span",{class:"hljs-title class_"},"Comparable"),(0,r.Uk)("[] = [];\n\n  "),(0,r._)("span",{class:"hljs-keyword"},"for"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" sz = "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)("; sz < length; sz += sz + sz) { "),(0,r._)("span",{class:"hljs-comment"},"// sz 子数组大小"),(0,r.Uk)("\n    "),(0,r._)("span",{class:"hljs-keyword"},"for"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" lo = "),(0,r._)("span",{class:"hljs-number"},"0"),(0,r.Uk)("; lo < length - sz; lo += sz + sz) { "),(0,r._)("span",{class:"hljs-comment"},"// 子数组索引"),(0,r.Uk)("\n      "),(0,r._)("span",{class:"hljs-title function_"},"merge"),(0,r.Uk)("(arr, lo, lo + sz - "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(", "),(0,r._)("span",{class:"hljs-title class_"},"Math"),(0,r.Uk)("."),(0,r._)("span",{class:"hljs-title function_"},"min"),(0,r.Uk)("(lo + sz + sz - "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(", length -"),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)("))\n    }\n  }\n\n}\n\n")])]),(0,r._)("p",null,"不管元素在什么情况下都要做这些步骤，所以花销的时间是不变的，所以该算法的最优时间复杂度和最差时间复杂度及平均时间复杂度都是一样的为：O( nlogn )"),(0,r._)("p",null,"空间复杂度为: O(n)。"),(0,r._)("h3",null,"快速排序"),(0,r._)("p",null,"快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-ts"},[(0,r.Uk)("\n  "),(0,r._)("span",{class:"hljs-keyword"},"function"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"quickSort"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-params"},"arr: Comparable[]"),(0,r.Uk)(") {\n    "),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("(arr, "),(0,r._)("span",{class:"hljs-number"},"0"),(0,r.Uk)(", arr."),(0,r._)("span",{class:"hljs-property"},"lenght"),(0,r.Uk)(" - "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(");\n\n    "),(0,r._)("span",{class:"hljs-keyword"},"function"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-params"},"array: Comparable[], lo, hi"),(0,r.Uk)(") {\n      "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("(hi <= lo) "),(0,r._)("span",{class:"hljs-keyword"},"return"),(0,r.Uk)(";\n\n      "),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" j = "),(0,r._)("span",{class:"hljs-title function_"},"partition"),(0,r.Uk)("(array, lo, hi); "),(0,r._)("span",{class:"hljs-comment"},"// 切分"),(0,r.Uk)("\n\n      "),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("(array, lo, j - "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(");\n      "),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r.Uk)("(array, j + "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(", hi);\n    }\n\n    "),(0,r._)("span",{class:"hljs-keyword"},"function"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"partition"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-params"},"array: Comparable[], lo , hi"),(0,r.Uk)(") {\n      "),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" i = lo; "),(0,r._)("span",{class:"hljs-keyword"},"let"),(0,r.Uk)(" j = hi + "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(";\n\n      "),(0,r._)("span",{class:"hljs-keyword"},"const"),(0,r.Uk)(" v = array[lo];\n\n      "),(0,r._)("span",{class:"hljs-keyword"},"while"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-literal"},"true"),(0,r.Uk)(") {\n        "),(0,r._)("span",{class:"hljs-keyword"},"while"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-title function_"},"less"),(0,r.Uk)("(array[++i], v)) "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("(i == hi) "),(0,r._)("span",{class:"hljs-keyword"},"break"),(0,r.Uk)(";\n        "),(0,r._)("span",{class:"hljs-keyword"},"while"),(0,r.Uk)("("),(0,r._)("span",{class:"hljs-title function_"},"less"),(0,r.Uk)("(v, arry[--j])) "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("(j == lo) "),(0,r._)("span",{class:"hljs-keyword"},"break"),(0,r.Uk)(";\n\n        "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)("(j <= i ) "),(0,r._)("span",{class:"hljs-keyword"},"break"),(0,r.Uk)(";\n        "),(0,r._)("span",{class:"hljs-title function_"},"exch"),(0,r.Uk)("(array, i, j);\n      }\n\n      "),(0,r._)("span",{class:"hljs-title function_"},"exch"),(0,r.Uk)("(array, lo, j);\n\n      "),(0,r._)("span",{class:"hljs-keyword"},"return"),(0,r.Uk)(" j;\n\n    }\n  }\n\n")])]),(0,r._)("p",null,[(0,r.Uk)("快速排序的平均时间复杂度是 O(nlogn), 但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 O(n2) "),(0,r._)("strong",null,"(即已经排序好的数组))"),(0,r.Uk)(" , 所以开始可以先打乱数组的顺序保持随机性.而且对于小数组,其实快速排序比插入排序慢;所以可以混合使用;")]),(0,r._)("p",null,"快速排序只是使用数组原本的空间进行排序;"),(0,r._)("p",null,"快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。"),(0,r._)("p",null,"快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。"),(0,r._)("h3",null,"堆排序"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-java"},[(0,r._)("span",{class:"hljs-keyword"},"public"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"static"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"sort"),(0,r._)("span",{class:"hljs-params"},"(Comparable[] a)"),(0,r.Uk)("\n{\n   "),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-variable"},"N"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-operator"},"="),(0,r.Uk)(" a.length;\n   "),(0,r._)("span",{class:"hljs-keyword"},"for"),(0,r.Uk)(" ("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-variable"},"k"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-operator"},"="),(0,r.Uk)(" N/"),(0,r._)("span",{class:"hljs-number"},"2"),(0,r.Uk)("; k >= "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)("; k--)\n      sink(a, k, N);\n   "),(0,r._)("span",{class:"hljs-keyword"},"while"),(0,r.Uk)(" (N > "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(")\n   {\n      exch(a, "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(", N--);\n      sink(a, "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(", N);\n   }\n}\n")])]),(0,r._)("p",null,[(0,r.Uk)("以上代码中,第一个循环,构造了一个二叉堆, 第二个循环,依次将堆顶元素和最后一个元素交换,并通过缩小数组N的值来弹出原堆顶 "),(0,r._)("strong",null,"(最值)"),(0,r.Uk)(" 缩小堆的大小.")]),(0,r._)("p",null,[(0,r.Uk)("在前面文章 "),(0,r._)("strong",null,"(优先队列)"),(0,r.Uk)(" 里介绍过的,由数组构造的二叉堆中,父节点位置为"),(0,r._)("strong",null,"k"),(0,r.Uk)("时,子节点分别为"),(0,r._)("strong",null,"2k"),(0,r.Uk)("和"),(0,r._)("strong",null,"2k+1"),(0,r.Uk)(",所以从 "),(0,r._)("strong",null,"N/2"),(0,r.Uk)("的位置找到最大的父节点,并依次"),(0,r._)("strong",null,"sink"),(0,r.Uk)("操作(sink操作见优先队列),从而达到堆有序.")]),(0,r._)("p",null,"如下图:"),(0,r._)("p",null,[(0,r._)("img",{src:"'../assets/%E5%A0%86%E6%8E%92%E5%BA%8F.png'",alt:"堆排序"})])])],-1),y=[U];function d(s,l){return(0,r.wg)(),(0,r.iD)("section",null,y)}const m={},w=(0,o.Z)(m,[["render",d]]);var b=w,f=(n(29),{name:"Sort",components:{SortMd:b}});const g=(0,o.Z)(f,[["render",j]]);var v=g;const q={class:"markdown-body"};function N(s,l,n,a,e,p){const t=(0,r.up)("PriorityQueueMd");return(0,r.wg)(),(0,r.iD)("div",q,[(0,r.Wm)(t)])}const x=(0,r._)("html",null,[(0,r._)("head"),(0,r._)("body",null,[(0,r._)("h2",null,"优先队列 (算法第四版2.4)"),(0,r._)("p",null,"普通队列是一种先进先出的数据结构，先放进队列的元素取值时优先被取出来。而优先队列是一种具有最高优先级元素先出的数据结构，比如每次取值都取最大的元素, 它包含最重要的两种操作: 删除最大元素delMax和插入元素insert()."),(0,r._)("h3",null,"堆的定义"),(0,r._)("p",null,"当一颗二叉树的每个节点都大于等于它的两个子节点时,它被称为堆有序, 所以根节点是堆有序的二叉树中的最大节点"),(0,r._)("h3",null,"二叉堆表示法"),(0,r._)("h4",null,"完全二叉树的定义"),(0,r._)("p",null,"二叉树除开最后一层，其他层结点数都达到最大，最后一层的所有结点都集中在左边（左边结点排列满的情况下，右边才能缺失结点）"),(0,r._)("h4",null,"数组表示完全二叉树"),(0,r._)("p",null,"如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）. 如果我们使用完全二叉树，表达就会变得特别方便"),(0,r._)("p",null,[(0,r.Uk)("完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。 "),(0,r._)("strong",null,"（不使用数组的第一个位置, 哨兵）")]),(0,r._)("p",null,[(0,r._)("strong",null,"简单起见，在下文中我们将二叉堆简称为堆）"),(0,r.Uk)(" 在一个堆中，位置 "),(0,r._)("strong",null,"k"),(0,r.Uk)(" 的结点的父结点的位置为 "),(0,r._)("strong",null,"k / 2"),(0,r.Uk)("而它的两个子结点的位置则分别为 "),(0,r._)("strong",null,"2k"),(0,r.Uk)(" 和 "),(0,r._)("strong",null,"2k+1"),(0,r.Uk)("。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1。")]),(0,r._)("blockquote",null,[(0,r._)("p",null,[(0,r._)("strong",null,"命题 P"),(0,r.Uk)("。一棵大小为 "),(0,r._)("strong",null,"N"),(0,r.Uk)(" 的完全二叉树的高度为 "),(0,r._)("strong",null,"lgN"),(0,r.Uk)("。")])]),(0,r._)("blockquote",null,[(0,r._)("p",null,[(0,r._)("strong",null,"证明"),(0,r.Uk)("。通过归纳很容易可以证明这一点，且当 达到 2 的幂时树的高度会加 1。")])]),(0,r._)("h3",null,"堆的算法"),(0,r._)("p",null,[(0,r.Uk)("我们用长度为 "),(0,r._)("strong",null,"k + 1"),(0,r.Uk)(" 的私有数组 pq[] 来表示一个大小为 "),(0,r._)("strong",null,"k"),(0,r.Uk)(" 的堆，我们不会使用 pq[0]，堆元素放在 pq[1] 至 pq[N] 中")]),(0,r._)("h4",null,"堆实现的比较和交换方法"),(0,r._)("p",null,"因为所有的元素都在数组 pq[] 中，不再将数组作为参数传递"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-java"},[(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-type"},"boolean"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"less"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" i, "),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" j)")]),(0,r.Uk)("\n{  "),(0,r._)("span",{class:"hljs-keyword"},"return"),(0,r.Uk)(" pq[i].compareTo(pq[j]) < "),(0,r._)("span",{class:"hljs-number"},"0"),(0,r.Uk)(";  }\n\n"),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"exch"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" i, "),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" j)")]),(0,r.Uk)("\n{  "),(0,r._)("span",{class:"hljs-type"},"Key"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-variable"},"t"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-operator"},"="),(0,r.Uk)(" pq[i]; pq[i] = pq[j]; pq[j] = t;  }\n\n")])]),(0,r._)("h4",null,"由下自上的堆有序化（上浮）"),(0,r._)("p",null,"当调用优先队列的insert方法时，我们首先把元素放置到数组的结尾，然后再把该元素上浮到正确的节点，最终形成堆有序状态。"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-java"},[(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"swim"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" k)")]),(0,r.Uk)("\n{\n   "),(0,r._)("span",{class:"hljs-keyword"},"while"),(0,r.Uk)(" (k > "),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(" && less(k/"),(0,r._)("span",{class:"hljs-number"},"2"),(0,r.Uk)(", k))\n   {\n      exch(k/"),(0,r._)("span",{class:"hljs-number"},"2"),(0,r.Uk)(", k);\n      k = k/"),(0,r._)("span",{class:"hljs-number"},"2"),(0,r.Uk)(";\n   }\n}\n\n\n")])]),(0,r._)("h4",null,"由上至下的堆有序化（下沉）"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-java"},[(0,r.Uk)("\n"),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"sink"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" k)")]),(0,r.Uk)("\n{\n   "),(0,r._)("span",{class:"hljs-keyword"},"while"),(0,r.Uk)(" ("),(0,r._)("span",{class:"hljs-number"},"2"),(0,r.Uk)("*k <= N)\n   {\n      "),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-variable"},"j"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-operator"},"="),(0,r.Uk)(),(0,r._)("span",{class:"hljs-number"},"2"),(0,r.Uk)("*k;\n      "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)(" (j < N && less(j, j+"),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(")) j++;\n      "),(0,r._)("span",{class:"hljs-keyword"},"if"),(0,r.Uk)(" (!less(k, j)) "),(0,r._)("span",{class:"hljs-keyword"},"break"),(0,r.Uk)(";\n      exch(k, j);\n      k = j;\n   }\n}\n\n")])]),(0,r._)("p",null,[(0,r._)("img",{src:"'../assets/%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C.png'",alt:"堆的操作"})]),(0,r._)("h4"),(0,r._)("pre",null,[(0,r._)("code",{"v-pre":"",class:"language-java"},[(0,r.Uk)("\n"),(0,r._)("span",{class:"hljs-keyword"},"public"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"class"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title class_"},"MaxPQ"),(0,r.Uk)("<Key "),(0,r._)("span",{class:"hljs-keyword"},"extends"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title class_"},"Comparable"),(0,r.Uk)("<Key>>\n{\n  "),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(" Key[] pq;             "),(0,r._)("span",{class:"hljs-comment"},"// 基于堆的完全按二叉树”"),(0,r.Uk)("\n  "),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-variable"},"N"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-operator"},"="),(0,r.Uk)(),(0,r._)("span",{class:"hljs-number"},"0"),(0,r.Uk)(";            "),(0,r._)("span",{class:"hljs-comment"},"// 存储于pq[1..N]中，pq[0]没有使用"),(0,r.Uk)("\n\n   "),(0,r._)("span",{class:"hljs-keyword"},"public"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"MaxPQ"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" maxN)")]),(0,r.Uk)("\n   {  pq = (Key[]) "),(0,r._)("span",{class:"hljs-keyword"},"new"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title class_"},"Comparable"),(0,r.Uk)("[maxN+"),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)("];  }\n\n   "),(0,r._)("span",{class:"hljs-keyword"},"public"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-type"},"boolean"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"isEmpty"),(0,r._)("span",{class:"hljs-params"},"()"),(0,r.Uk)("\n   {  "),(0,r._)("span",{class:"hljs-type"},"return"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-variable"},"N"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-operator"},"="),(0,r.Uk)("= "),(0,r._)("span",{class:"hljs-number"},"0"),(0,r.Uk)(";  }\n\n   "),(0,r._)("span",{class:"hljs-keyword"},"public"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"size"),(0,r._)("span",{class:"hljs-params"},"()"),(0,r.Uk)("\n   {  "),(0,r._)("span",{class:"hljs-keyword"},"return"),(0,r.Uk)(" N;  }\n\n   "),(0,r._)("span",{class:"hljs-keyword"},"public"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"insert"),(0,r._)("span",{class:"hljs-params"},"(Key v)"),(0,r.Uk)("\n   {\n      pq[++N] = v;\n      swim(N);\n   }\n\n   "),(0,r._)("span",{class:"hljs-keyword"},"public"),(0,r.Uk)(" Key "),(0,r._)("span",{class:"hljs-title function_"},"delMax"),(0,r._)("span",{class:"hljs-params"},"()"),(0,r.Uk)("\n   {\n      "),(0,r._)("span",{class:"hljs-type"},"Key"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-variable"},"max"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-operator"},"="),(0,r.Uk)(" pq["),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)("];           "),(0,r._)("span",{class:"hljs-comment"},"// 从根结点得到最大元素"),(0,r.Uk)("\n      exch("),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(", N--);              "),(0,r._)("span",{class:"hljs-comment"},"// 将其和最后一个结点交换"),(0,r.Uk)("\n      pq[N+"),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)("] = "),(0,r._)("span",{class:"hljs-literal"},"null"),(0,r.Uk)(";            "),(0,r._)("span",{class:"hljs-comment"},"// 防止对象游离"),(0,r.Uk)("\n      sink("),(0,r._)("span",{class:"hljs-number"},"1"),(0,r.Uk)(");                   "),(0,r._)("span",{class:"hljs-comment"},"// 恢复堆的有序性"),(0,r.Uk)("\n      "),(0,r._)("span",{class:"hljs-keyword"},"return"),(0,r.Uk)(" max;\n   }\n\n   "),(0,r._)("span",{class:"hljs-comment"},"// 辅助方法的实现请见本节前面的代码框"),(0,r.Uk)("\n   "),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-type"},"boolean"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"less"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" i, "),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" j)")]),(0,r.Uk)("\n   "),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"exch"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" i, "),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" j)")]),(0,r.Uk)("\n   "),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"swim"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" k)")]),(0,r.Uk)("\n   "),(0,r._)("span",{class:"hljs-keyword"},"private"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-keyword"},"void"),(0,r.Uk)(),(0,r._)("span",{class:"hljs-title function_"},"sink"),(0,r._)("span",{class:"hljs-params"},[(0,r.Uk)("("),(0,r._)("span",{class:"hljs-type"},"int"),(0,r.Uk)(" k)")]),(0,r.Uk)("\n}\n\n")])]),(0,r._)("p",null,"优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。在 insert() 中，我们将 N 加一并把新元素添加在数组最后，然后用 swim() 恢复堆的秩序。在 delMax() 中，我们从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink() 恢复堆的秩序。同时我们还将不再使用的 pq[N+1] 设为 null，以便系统回收它所占用的空间。这里省略了动态调整数组大小的代码"),(0,r._)("blockquote",null,[(0,r._)("p",null,[(0,r._)("strong",null,"命题 Q"),(0,r.Uk)("。对于一个含有 "),(0,r._)("strong",null,"N"),(0,r.Uk)(" 个元素的基于堆的优先队列，插入元素操作只需不超过（"),(0,r._)("strong",null,"lgN + 1"),(0,r.Uk)("）次比较，删除最大元素的操作需要不超过 "),(0,r._)("strong",null,"2lgN"),(0,r.Uk)(" 次比较。")])]),(0,r._)("blockquote",null,[(0,r._)("p",null,[(0,r._)("strong",null,"证明"),(0,r.Uk)("。由命题 P 可知，两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过 "),(0,r._)("strong",null,"lgN"),(0,r.Uk)("。对于路径上的每个结点，删除最大元素需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。")])])])],-1),C=[x];function O(s,l){return(0,r.wg)(),(0,r.iD)("section",null,C)}const z={},M=(0,o.Z)(z,[["render",O]]);var E=M,D={name:"PriorityQueue",components:{PriorityQueueMd:E}};const P=(0,o.Z)(D,[["render",N]]);var K=P;const A=[{path:"/",component:u},{path:"/sort",component:v},{path:"/priority-queue",component:K}];var Q=A;function S(s,l,n,a,e,p){const t=(0,r.up)("router-view");return(0,r.wg)(),(0,r.j4)(t)}var Z={name:"App",components:{}};const W=(0,o.Z)(Z,[["render",S]]);var T=W;const B=(0,e.p7)({history:(0,e.r5)(),routes:Q}),F=(0,a.ri)(T);F.use(B),F.mount("#app")}},l={};function n(a){var e=l[a];if(void 0!==e)return e.exports;var r=l[a]={exports:{}};return s[a](r,r.exports,n),r.exports}n.m=s,function(){var s=[];n.O=function(l,a,e,r){if(!a){var p=1/0;for(_=0;_<s.length;_++){a=s[_][0],e=s[_][1],r=s[_][2];for(var t=!0,k=0;k<a.length;k++)(!1&r||p>=r)&&Object.keys(n.O).every((function(s){return n.O[s](a[k])}))?a.splice(k--,1):(t=!1,r<p&&(p=r));if(t){s.splice(_--,1);var c=e();void 0!==c&&(l=c)}}return l}r=r||0;for(var _=s.length;_>0&&s[_-1][2]>r;_--)s[_]=s[_-1];s[_]=[a,e,r]}}(),function(){n.d=function(s,l){for(var a in l)n.o(l,a)&&!n.o(s,a)&&Object.defineProperty(s,a,{enumerable:!0,get:l[a]})}}(),function(){n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(s){if("object"===typeof window)return window}}()}(),function(){n.o=function(s,l){return Object.prototype.hasOwnProperty.call(s,l)}}(),function(){var s={143:0};n.O.j=function(l){return 0===s[l]};var l=function(l,a){var e,r,p=a[0],t=a[1],k=a[2],c=0;if(p.some((function(l){return 0!==s[l]}))){for(e in t)n.o(t,e)&&(n.m[e]=t[e]);if(k)var _=k(n)}for(l&&l(a);c<p.length;c++)r=p[c],n.o(s,r)&&s[r]&&s[r][0](),s[r]=0;return n.O(_)},a=self["webpackChunkmyblog"]=self["webpackChunkmyblog"]||[];a.forEach(l.bind(null,0)),a.push=l.bind(null,a.push.bind(a))}();var a=n.O(void 0,[998],(function(){return n(510)}));a=n.O(a)})();
//# sourceMappingURL=app.78899eff.js.map