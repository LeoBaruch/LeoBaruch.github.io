{"pages":[],"posts":[{"title":"Cargo下载包太慢解决","text":"由于Cartes仓库源是github，更新太慢了，替换成国内的源。步骤如下: 打开或新建用户目录下/.cargo/config文件: ~/.cargo/config 在文件中增加以下配置 123456789101112131415161718192021222324252627[source.crates-io]registry = &quot;https://github.com/rust-lang/crates.io-index&quot;# 指定镜像(下面几个里选一个)replace-with = 'tuna'# 清华大学[source.tuna]registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;# 中国科学技术大学[source.ustc]registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;# 上海交通大学[source.sjtu]registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;# rustcc社区[source.rustcc0]registry = &quot;https://code.aliyun.com/rustcc/crates.io-index.git&quot;[source.rustcc1]registry=&quot;git://crates.rustcc.cn/crates.io-index&quot;[source.rustcc2]registry=&quot;git://crates.rustcc.com/crates.io-index&quot;","link":"/2023/08/15/Cargo%E4%B8%8B%E8%BD%BD%E5%8C%85%E5%A4%AA%E6%85%A2%E8%A7%A3%E5%86%B3/"},{"title":"字符编码笔记：ASCII，Unicode 和 UTF-8","text":"最近重新翻了一遍C语言, 看到字符串的相关的时候冒出一个问题, 在C中怎么得到字符串(包含汉字等非ascii码)的字符个数及遍历字符串.之前也粗略了解过unicod和utf-8相关, 但是随着时间推移, 也可能因为自己掌握不够熟练不知道从何下手,于是决定把它记下来. 阮一峰老师写的很好, 这里摘取部分他的博文. 并附带C的实现 ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 非 ASCII 编码英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 Unicode正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。 Unicode 的问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。 UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 、、、 // UTF-8编码方式（16进制 &amp;&amp; 二进制） 0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx、、、 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;locale.h&gt;int utf8_char_count(const char *str){ int count = 0; int len = strlen(str); int i = 0; while (i &lt; len) { unsigned char c = str[i]; int char_len = 0; // 二进制 c &lt;= 0b01111111 if (c &lt;= 0x7F) { // 单字节字符 char_len = 1; } // 二进制 c &amp; 0b11100000 == 0b11000000 else if ((c &amp; 0xE0) == 0xC0) { // 双字节字符 char_len = 2; } // 二进制 c &amp; 0b11110000 == 0b11100000 else if ((c &amp; 0xF0) == 0xE0) { // 三字节字符 char_len = 3; } // 二进制 c &amp; 0b11111000 == 0b11110000 else if ((c &amp; 0xF8) == 0xF0) { // 四字节字符 char_len = 4; } // 打印该字符 for (int j = 0; j &lt; char_len; j++) { printf(&quot;%c&quot;, str[i + j]); } printf(&quot;\\n&quot;); // 跳过该字符的字节 i += char_len; // 如果是有效的UTF-8字符，则增加计数 if (char_len &gt; 0) count++; } return count;}int main(){ setlocale(LC_ALL, &quot;&quot;); // 设置本地化环境，以支持UTF-8编码 char str[1000]; printf(&quot;请输入一个UTF-8编码的字符串：&quot;); fgets(str, sizeof(str), stdin); // 删除换行符 str[strcspn(str, &quot;\\n&quot;)] = '\\0'; int count = utf8_char_count(str); printf(&quot;字符个数：%d\\n&quot;, count); return 0;} 参考资料 字符编码笔记：ASCII，Unicode 和 UTF-8","link":"/2024/05/06/ascii-unicode-and-utf-8/"},{"title":"commit-message","text":"Commit message 提交标准Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交, 一般来说，commit message 应该清晰明了，说明本次提交的目的 本文介绍的是Angular 规范 commit message的格式包含: Header、Body和Footer 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略,暂时不讲 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）,简短,保持美观 HeaderHeader部分只有一行，包括三个字段： type（必需） scope（可选） subject（必需） typetype用于说明 commit 的类别，只允许使用下面7个标识。 1234567891011121314feat: Add new featuresfix: Fix the problem/BUGstyle: The code style is related and does not affect the running resultperf: Optimization/performance improvementrefactor: Refactorrevert: Undo edittest: Test relateddocs: Documentation/noteschore: Dependency update/scaffolding configuration modification etc.workflow: Workflow improvementsci: Continuous integrationtypes: Type definition file changeswip: In development 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subjectsubject是 commit 目的的简短描述，不超过50个字符。 比较规范的提交应该如下:","link":"/2022/05/26/commit-message/"},{"title":"conda安装与使用","text":"conda安装 以下为mac环境安装命令 1.安装1234567mkdir -p ~/miniconda3curl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh -o ~/miniconda3/miniconda.sh# intel 芯片# curl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh -o ~/miniconda3/miniconda.shbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3rm -rf ~/miniconda3/miniconda.sh 2.初始化123~/miniconda3/bin/conda init bash~/miniconda3/bin/conda init zsh 3.新建终端，检查 conda 是否安装成功12conda --version conda常用命令通用环境配置 新建虚拟环境: conda create -n [环境名] [python版本] 1conda create -n llm-universe python=3.10 激活虚拟环境: conda activate [环境名]1conda activate llm-universe 查看当前环境: conda info 查看所有安装python环境, 前面有符号*的表示当前激活环境: conda info –env 退出anaconda虚拟环境: conda deactivate 默认不进入anaconda的base环境: conda config –set auto_activate_base false","link":"/2025/06/22/conda%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/05/06/hello-world/"},{"title":"husky+lint-staged","text":"简介 husky: husky是一个为 git 客户端增加 hook 的工具，githooks - git使用的工具 (githook在官网的介绍)，比如 pre-commit 钩子就会在你执行 git commit 的触发 由于钩子可以在git commit中触发，所以我们可以在提交到暂缓区时，做一些lint 检查、单元测试、代码美化等操作 lint-staged: 一个仅仅过滤出 Git 代码暂存区文件(被 git add 的文件)的工具 安装与使用husky（最好参照官网，实时更新）:12345npx husky-init &amp;&amp; npm install # npmnpx husky-init &amp;&amp; yarn # Yarn 1yarn dlx husky-init --yarn2 &amp;&amp; yarn # Yarn 2+pnpm dlx husky-init &amp;&amp; pnpm install # pnpm 这行命令会修改package.json文件，设置并初始化一个pre-commit钩子的小样供你编辑，添加你想要的操作, 默认是: npm test; 1234567// package.json scripts会添加两行scripts: { &quot;prepare&quot;: &quot;husky install&quot;, &quot;lint-staged&quot;: &quot;lint-staged&quot;} 1234567// 新增 .husky文件夹 其中 pre-commit文件npm test改成其他命令// 比如后面添加的lint-staged #!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;npm run lint-staged # npm test lint-staged1npm i lint-staged -D 然后在package.json里面配置 12345678&quot;lint-staged&quot;: { &quot;src/**/*.{js,vue}&quot;: [ &quot;prettier --write&quot;, &quot;eslint --fix&quot;, &quot;git add&quot; ]} 因为上文husky 在pre-commit的时候会运行npm run lint-staged命令，然后执行scripts里面的lint-staged, 最后找到lint-staged里面配置执行下面三条： 第一条命令是将代码进行格式化，用prettier这个代码格式化插件进行代码格式化。 第二条命令是将格式化的代码上有eslint问题，进行修复。 第三条命令是将处理过的代码重新 add 到 git 中。","link":"/2023/10/19/husky-lint-staged/"},{"title":"mac-tools","text":"Mac各种效率工具 开发 vscode: 编辑器 Charles: 抓包工具 postman: 测试api iTerm2: 终端神器 navicat: 数据库gui 命令行工具 on my zsh: a delightful, open source, community-driven framework for managing your Zsh configuration fasd: Fasd offers quick access to files and directories for POSIX shells. 效率 alfred4 Bartender4: Menubar 菜单栏管理小助手 macdown: markdown VPN: clashX IINA: 视频播放器 Karabiner-Elements: mac键位修改神器 moom 窗口整理、排列、缩放工具 Manico 应用启动和切换工具","link":"/2022/05/26/mac-tools/"},{"title":"npm版本规则及发布","text":"版本号规则从日常的开发中我们可以看到，npm 包的版本号的格式都是 X.Y.Z。这个格式其实是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。由 GitHub 起草的统一的版本号表示规则，称为 Semantic Versioning(语义化版本表示) X 代表主版本号，也叫做大版本号升级大版本时意味着这个包可能做了颠覆性的改动，和低版本的包已经无法兼容。每当主版本号递增时，次版本号和修订号必须归零。 Y 代表次版本号，也叫做小版本号当做了向下兼容的功能性新增时，升级小版本号。每当次版本号递增时，修订号必须归零。 Z 代表修订号当做了向下兼容的问题修正（bugfix）时， 升级修订号。 常见版本格式/引用方式 版本引用方式 版本号 匹配版本 解释 直接使用版本号 2.3.1 2.3.1 只可以匹配 2.3.1 这个版本，如果是比较重要的项目，建议用这种方式固定版本。 ^: 不能修改版本号最左侧非零数字 ^2.3.1 &gt;= 2.3.1 &amp;&amp; &lt; 3.0.0 最左侧非零数字是 2 ^0.3.1 ^0.3.1 &gt;= 0.3.1 &amp;&amp; &lt; 0.4.0 最左侧非零数字是 3 ^0.0.1 ^0.01 &gt;= 0.01 &amp;&amp; &lt; 0.02 最左侧非零数字是 1 ~: 版本号列出 Y 时兼容 Z 的修改 ~2.3.1 &gt;= 2.3.1 &amp;&amp; &lt; 2.4.0 Y 为 3。～2.3 同理 ～2 ～2 &gt;= 2.0.0 &amp;&amp; &lt; 3.0.0 X 为 2 *、X、x，空：表示可以匹配任何版本 “2.3.X” &gt;= 2.3.0 &amp;&amp; &lt; 2.4.0 Z 可以为任意值 “2.X”、”2.x”、”2.*”、”2” “2.X” &gt;= 2.0.0 &amp;&amp; &lt; 3.0.0 Y、Z 为任意值 *、X、x，空 任意版本 任意版本 任意版本指的是最新的正式版 先行版本npm 的先行版本号，放到 X.Y.Z 的后边，作为延伸。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。例如：1.0.0-alpha.1，2.0.0-beta.1 等。一般常用的关键词有： alpha：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug（会不太稳定）；一般只有测试人员使用。beta：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。 版本查看以webpack为例: 1npm dist-tag ls webpack 版本发布手动修改package.json里面的version 12&quot;name&quot;: &quot;package-name&quot;,&quot;version&quot;: &quot;2.3.2-beta.1&quot; 使用 npm publish来发布的话，发布出来的包的 tag 是 latest，但是我们其实是想发布一个测试包。如果其他人 npm i 下载时就会下载 version 为 2.3.2-beta.1 的包。只有使用 npm publish –tag XXX 才是给 npm 包上打了 tag 标签 12npm run build // 打包npm publish --tag beta // 发布 beta 包 如果不小心直接使用 npm publish 发错了也没有关系，可以使用以下命令来添加 tag： 1npm dist-tag add &lt;pkg&gt;@2.3.2-beta.1 &lt;tag&gt; 当需要删除多余的 tag 时： 1npm dist-tag rm &lt;pkg&gt; &lt;tag&gt;","link":"/2023/10/19/npm%E7%89%88%E6%9C%AC%E8%A7%84%E5%88%99%E5%8F%8A%E5%8F%91%E5%B8%83/"},{"title":"几种查找的数据结构(二叉搜索树、2-3树及红黑树)","text":"现代计算机和网络使我们能够访问海量的信息。高效检索这些信息的能力是处理它们的重要前提.本文主要介绍几种经典的数据结构,及分析其插入和查找效率 链表下图为一个基于单向链表的添加与查找的轨迹.每次插入一个新元素前先查找是否存在相同的key,不存在则在首部新增一个节点,存在则替换当前节点的值. 由上图可知,一个链表长度为N插入一个新数据的时间复杂度为 O(1), 即只需在首部插入即可.而查找,需要每个节点依次寻找,最好为1,最差为N.平均时间复杂度为O(N) 有序数组无序数组与链表类似,查询依次为O(N),添加为O(1); 有序数组的查找分两种: 一种是顺序查找时间复杂度为O(N), 另一种是二分查找时间复杂度是O(logN).添加时间复杂度为O(N), 插入流程如下图: 二叉查找树以上两种数据结构插入和查找的时间复杂度如下表 数据结构 查找 插入 链表 O(N) O(1) 有序数组(顺序查找) O(N) O(N) 有序数组(二分查找) O(log N) O(N) 由上图可以看出不论是链表与数组,他的查找和插入顺序都不是很尽如人意, 若构建一个长度为N的数据,两种存储方式: 链表: 插入次数 为 N * 1, 查询替换为 N * N, 查询速度太慢 数组(二分查找): 插入为 N * N, 查询替换为 NlogN, 插入速度太慢 那有没有一个数据结构能不能兼具查询和插入都足够效率的优点呢.这里我们先介绍下二叉查找树的基本特征.然后再分析 二叉查找树定义一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键. 每一个二叉搜索树的左右子树也都是一个二叉搜索树 二叉搜索树如果用中序遍历一下，就是一个从小到大的递增序列 下图是一颗二叉查找树, 中序遍历得到的结果是 A C E H R S X 二叉查找树查找在二叉查找树中分别查找 R 和 T R: 先找根节点 S, R小于S, 在 S的左子树查找, 左子树根节点 E, R大于 E, 则在E的右子树找, 右子树根节点 R, 命中. T: 先找根节点 S, T小于S, 在 S的右子树查找, 左子树根节点 X, T小于 X, 则在E的右子树找, 左子树根节点为空, 未命中 二叉查找树插入二叉查找树的查找几乎和二分查找的一样简单,而且插入的实现难度和查找差不多,当要插入的节点的键在二叉查找树查找树命中时,则直接替换命中键的值.未被命中为空节点时,如果被查找的键小于空节点根结点的键，我们会继续在左子树中插入该键，否则在右子树中插入该键。 平衡二叉树的2-3树·概念什么是平衡二叉树: 可以是空树。 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。 分析使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一棵含有 N 个结点的树是完全平衡的，每条空链接和根结点的距离都为 logN。在最坏的情况下，搜索路径上可能有 N个结点, 变成了一个链表.如图所示。但在一般情况下树的形状和最好情况更接近。 2-3树上面说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为N,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了2-3树概念 2-3树定义为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成: 2-节点: 标准的二叉查找树中的节点.含有一个键（及其对应的值）和两条链接,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。 3-节点: 含有两个键（及其对应的值）和三条链接，左链接指向的目标节点的键都小于该结点，中链接指向的目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。 注: 一棵完美平衡的 2-3 查找树中的所有空链接到根结点的距离都应该是相同的。简洁起见，这里我们用 2-3 树指代一棵完美平衡的 2-3 查找树（在其他情况下这个词应该表示一种更一般的结构） 2-3树的查找将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中 下图为对H的命中查找及对B的未命中查找: 2-3树插入空树的插入很简单,创建一个节点即可.非空树则分四种情况: 向2-节点中插入元素； 向一颗只含有一个3-节点的树中插入元素； 向一个父节点为2-节点的3-节点中插入元素； 向一个父节点为3-节点的3-节点中插入元素2-3树 向2-节点中插入元素如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点 向一颗只含有一个3-节点的树中插入元素我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树 向一个父节点为2-节点的3-节点中插入元素我们先像刚才一样构造一个临时的 4- 结点并将其分解, 但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中, 父结点是一个 2- 结点（一个键两条链接），插入之后变为了一个 3- 结点. 这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同 向一个父节点为3-节点的3-节点中插入元素再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根,然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树 分解根节点 2-3树节点关系 2-3树构造轨迹: 即使升序插入也不会退化为链表,如下图所示: 性质:和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的 命题 F在一棵大小为 的 2-3 树中，查找和插入操作访问的结点必然不超过lgN 证明。一棵含有 N 个结点的 2-3 树的高度在 log3 N（如果树中全是 3- 结点）和 log2 N（如果树中全是 2- 结点）之间 红黑树二叉搜索树上文中2-3树可以实现树的有序性与平衡性,但是要维护两种不同类型的节点(2-节点与3-节点),将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢. 红黑树二叉搜索树替换2-3树红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由 2- 结点构成）和一些额外的信息（替换 3- 结点）来表示 2-3 树.树的链接分为两种: 红链接将两个 2- 结点连 红黑树二叉搜索树定义红黑树是含有红黑链接并满足下列条件的二叉查找树： 红链接均为左链接； 没有任何一个结点同时和两条红链接相连； 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 满足这样定义的红黑树和相应的 2-3 树是一一对应的 红黑树二叉搜索树的插入每次插入的节点的时候都将节点的颜色初始化为红色 旋转在我们实现的某些操作中(比如插入)可能会出现红色右链接或者两条连续的红链接,需要通过旋转和变换颜色修复,旋转操作会改变红链接的指向, 左旋转 右旋转 无论是rotateRight()或rotateLeft() , 我们总是将其返回值重置父结点（或是根结点),且保留原来父节点的颜色(将 x.color 设为 h.color) 颜色变换当我们的节点经过左右旋转时,有可能出现左右节点均为红色的场景,此时,我们需要颜色变换. 我们专门用一个方法 flipColors() 来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将父结点的颜色由黑变红(相当于父节点上浮,和它的父节点结合成为一个3-节点),这项操作和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性. 红黑树的链接向上传递只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作, 在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作： 如果右子结点是红色的而左子结点是黑色的，进行左旋转； 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转； 如果左右子结点均为红色，进行颜色转换。 注意,红黑树的根节点为黑色! 复合的插入过程 完整得建立一颗红黑树","link":"/2022/06/12/search/"},{"title":"tapable","text":"在阅读webpack的源码过程中,发现webpack编译的两个核心对象Compiler和Compilation都是继承自tapable, : Compiler: 负责整体编译流程的 Compilation: 负责编译Module 所以熟悉tapable还是很有必要的,而apable本质上实现了一种发布订阅模式. Tapable使用版本1&quot;tapable&quot;: &quot;^2.2.1&quot; 使用及分类官方一共提供了9种钩子 123456789101112const { SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook } = require(&quot;tapable&quot;); 基本使用 new 实例化一个钩子函数, 接收两个参数: 参数一: 为字符串数组, 数组中的值不重要,数组中个数对应后面监听方法tap的回调函数形参和触发事件方法call的实参个数; 参数二: 应用较少不需要额外介绍(官方文档也无体现) tap函数 监听对应的事件，注册事件时接受两个参数： 参数一: 字符串(作为标识位)或对象(可以额外设置触发优先级等) 参数二: 回调函数, 形参对应步骤1中参数一的字符串数组个数 call函数 触发步骤二中tap中的回调函数 分类按照同步/异步分类Tapable 中所有注册的事件可以分为同步、异步两种执行方式: 同步钩子: tap 方法是唯一的注册事件的方法，call 唯一调用方法 异步钩子可以通过 tap、tapAsync、tapPromise三种方式来注册，并依次通过对应的 call、callAsync、promise 三种方式触发注册的函数。 且异步钩子也分为两类: 异步串行( AsyncSeries )：可以被串联（连续按照顺序调用）执行的异步钩子。 异步并行( AsyncParallel )：可以被并联（并发调用）执行的异步钩子。 按照执行机制分类Tapable 可以按照异步/同步执行分类的同时也可以按照执行机制进行分类，比如： Basic Hook : 基本类型的钩子，它仅仅执行钩子注册的事件，并不关心每个被调用的事件函数返回值如何。 Bail : 保险类型钩子，保险类型钩子在基础类型钩子上增加了一种保险机制，如果任意一个注册函数执行返回非 undefined 的值，那么整个钩子执行过程会立即中断，之后注册事件函数就不会被调用了。 Waterfall : 瀑布类型的钩子，瀑布类型的钩子和基本类型的钩子基本类似，唯一不同的是瀑布类型的钩子会在注册的事件执行时将事件函数执行非 undefined 的返回值传递给接下来的事件函数作为参数。 Loop : 循环类型钩子，循环类型钩子稍微比较复杂一点。循环类型钩子通过 call 调用时，如果任意一个注册的事件函数返回值非 undefeind ,那么会立即重头开始重新执行所有的注册事件函数，直到所有被注册的事件函数都返回 undefined。 demo地址 参考资料 https://github.com/webpack/tapable https://juejin.cn/post/7040982789650382855#heading-3","link":"/2024/05/06/tapable/"},{"title":"webpack-cli 源码解析(上)","text":"文中所引用的源码版本: webpack@4.46.0 webpack 命令当我们在项目中的package.json中的字段“scripts”对象配置属性: “build”: “webpack entry.js bundle.js” . 然后npm run build会发生什么呢? 首先npm会让命令行工具进入node_modules/.bin目录中查询是否存在“webpack“命令,若存在则执行,没找到则报错.实际命令的入口文件是“webpack”这个npm包的package.json中bin字段的文件路径, 即 node_modules/webpack/bin/webpack.js. 1&quot;bin&quot;: &quot;./bin/webpack.js&quot;, 分析 /bin/webpack.js源码大致流程是,判断是否安装了命令行工具webpack-cli(或者webpack-command, 默认webpack-cli), 若没有安装,则提示安装webpack-cli, 若安装了其中一个,则引用(执行) 若两个命令行工具都安装了,则提示卸载其中一个或者直接执行他们自己的命令(webpack-cli xx xx). 原文: please remove one of them or use them directly via their binary. 判断命令行是否安装逻辑12345678910111213141516171819202122232425262728293031323334353637// 使用node内部的 require() 工具查找模块的位置，但不加载模块，只返回解析的文件名。// 如果找不到模块，则会抛出 MODULE_NOT_FOUND 错误。const isInstalled = packageName =&gt; { try { require.resolve(packageName); return true; } catch (err) { return false; }};const CLIs = [ { name: &quot;webpack-cli&quot;, package: &quot;webpack-cli&quot;, binName: &quot;webpack-cli&quot;, alias: &quot;cli&quot;, installed: isInstalled(&quot;webpack-cli&quot;), recommended: true, url: &quot;https://github.com/webpack/webpack-cli&quot;, description: &quot;The original webpack full-featured CLI.&quot; }, { name: &quot;webpack-command&quot;, package: &quot;webpack-command&quot;, binName: &quot;webpack-command&quot;, alias: &quot;command&quot;, installed: isInstalled(&quot;webpack-command&quot;), recommended: false, url: &quot;https://github.com/webpack-contrib/webpack-command&quot;, description: &quot;A lightweight, opinionated webpack CLI.&quot; }];const installedClis = CLIs.filter(cli =&gt; cli.installed); 没有安装命令行当上面代码中的installedClis.length === 0时,即没有安装任何命令行工具,则提示安装webpack-cli 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 const runCommand = (command, args) =&gt; { const cp = require(&quot;child_process&quot;); return new Promise((resolve, reject) =&gt; { const executedCommand = cp.spawn(command, args, { stdio: &quot;inherit&quot;, shell: true }); executedCommand.on(&quot;error&quot;, error =&gt; { reject(error); }); executedCommand.on(&quot;exit&quot;, code =&gt; { if (code === 0) { resolve(); } else { reject(); } }); }); }; // 判断是否使用yarn安装包const isYarn = fs.existsSync(path.resolve(process.cwd(), &quot;yarn.lock&quot;));const packageManager = isYarn ? &quot;yarn&quot; : &quot;npm&quot;;const installOptions = [isYarn ? &quot;add&quot; : &quot;install&quot;, &quot;-D&quot;];console.error( `We will use &quot;${packageManager}&quot; to install the CLI via &quot;${packageManager} ${installOptions.join( &quot; &quot; )}&quot;.`);const question = `Do you want to install 'webpack-cli' (yes/no): `;const questionInterface = readLine.createInterface({ input: process.stdin, output: process.stderr});questionInterface.question(question, answer =&gt; { questionInterface.close(); const normalizedAnswer = answer.toLowerCase().startsWith(&quot;y&quot;); if (!normalizedAnswer) { console.error( &quot;You need to install 'webpack-cli' to use webpack via CLI.\\n&quot; + &quot;You can also install the CLI manually.&quot; ); process.exitCode = 1; return; } const packageName = &quot;webpack-cli&quot;; console.log( `Installing '${packageName}' (running '${packageManager} ${installOptions.join( &quot; &quot; )} ${packageName}')...` ); // 安装完webpack-cli 后 require 引入 runCommand(packageManager, installOptions.concat(packageName)) .then(() =&gt; { require(packageName); //eslint-disable-line }) .catch(error =&gt; { console.error(error); process.exitCode = 1; });}); 只安装了一个命令行工具123456789101112 const path = require(&quot;path&quot;); // 解析出package.json路径const pkgPath = require.resolve(`${installedClis[0].package}/package.json`);const pkg = require(pkgPath); // 注意: 这里是为了拼接引入bin命令的文件,而不是模块主入口(默认引入“main”字段)require(path.resolve( // package.json所在目录 path.dirname(pkgPath), // bin字段的入口文件相对路径 pkg.bin[installedClis[0].binName]));","link":"/2022/05/03/webpack-cli1/"},{"title":"安装gowatch","text":"安装gowatch 1go get github.com/silenceper/gowatch 安装完后在GOPATH的bin目录下, 把gowath 移动到全局(GOROOT)的bin目录下, 使用 go env查看目录 1go env 得到, 其中包含目录GOPATH及GOROOT 1234567891011121314151617181920GO111MODULE=&quot;on&quot;GOARCH=&quot;arm64&quot;GOBIN=&quot;&quot;GOCACHE=&quot;/Users/gexiaolong/Library/Caches/go-build&quot;GOENV=&quot;/Users/gexiaolong/Library/Application Support/go/env&quot;GOEXE=&quot;&quot;GOEXPERIMENT=&quot;&quot;GOFLAGS=&quot;&quot;GOHOSTARCH=&quot;arm64&quot;GOHOSTOS=&quot;darwin&quot;GOINSECURE=&quot;&quot;GOMODCACHE=&quot;/Users/gexiaolong/go/pkg/mod&quot;GONOPROXY=&quot;&quot;GONOSUMDB=&quot;&quot;GOOS=&quot;darwin&quot;GOPATH=&quot;/Users/gexiaolong/go&quot;GOPRIVATE=&quot;&quot;GOPROXY=&quot;https://goproxy.cn,direct&quot;GOROOT=&quot;/usr/local/go&quot;GOSUMDB=&quot;sum.golang.org&quot; 最后移动 sudo mv /Users/gexiaolong/go/bin/gowatch /usr/local/go/bin/gowatch 成功后就可以在 项目中直接使用gowatch命令了","link":"/2022/09/29/%E5%AE%89%E8%A3%85gowatch/"},{"title":"输入框光标位置及内容设置","text":"首先介绍几个HTMLInputElement(后面简称el)api(现代浏览器): el.setSelectionRange(selectionStart, selectionEnd [, selectionDirection]): 指定当前选中文本的起始和结束位置(当selectionStart===selectionEnd时为设置光标的位置)， el.selectionStart: 获取选中文本（或者光标）起始索引， el.setRangeText(replacement[, start, end, selectMode)]: replacement(要插入的内容)，start(要替换的第一个字符的从0开始的索引。默认为当前的selectionStart值(用户当前选择的开始)), end(The 0-based index of the character after the last character to replace. Defaults to the current selectionEnd value (the end of the user’s current selection)),selectMode 可以不传，详情查询文档 以下为demo: 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;input输入框&lt;/title&gt;&lt;script&gt; // 点击按钮，input输入框不会失去焦点 document.addEventListener(&quot;mousedown&quot;, function(e){ if(e.target.id!==&quot;btn&quot;){ e.preventDefault() } }, false); function divClick(){ console.log(&quot;点击了button&quot;) const name = '要替换的变量'; let el = document.querySelector(&quot;#input&quot;); // 获取光标的索引位置 const cursorIndex = el.selectionStart; console.log('index: ', cursorIndex) // 光标内容添加 '{' 和 '}}', el.setRangeText('}', cursorIndex, cursorIndex ); el.setRangeText('{', cursorIndex, cursorIndex); // 设置光标位置 el.setSelectionRange(cursorIndex + 1, cursorIndex + 1); }&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;input&quot;&gt; &lt;button id=&quot;btn&quot; onClick=&quot;divClick()&quot;&gt;按钮&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2023/09/04/%E8%BE%93%E5%85%A5%E6%A1%86%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E5%8F%8A%E5%86%85%E5%AE%B9%E8%AE%BE%E7%BD%AE/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"rust cargo","slug":"rust-cargo","link":"/tags/rust-cargo/"},{"name":"utf-8 unicode ascii 字符编码","slug":"utf-8-unicode-ascii-字符编码","link":"/tags/utf-8-unicode-ascii-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"conda","slug":"conda","link":"/tags/conda/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"tools mac","slug":"tools-mac","link":"/tags/tools-mac/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"html js edit 编辑","slug":"html-js-edit-编辑","link":"/tags/html-js-edit-%E7%BC%96%E8%BE%91/"}],"categories":[{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"rust cargo","slug":"rust-cargo","link":"/categories/rust-cargo/"},{"name":"clang","slug":"clang","link":"/categories/clang/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"binary search tree","slug":"algorithm/binary-search-tree","link":"/categories/algorithm/binary-search-tree/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"html js","slug":"html-js","link":"/categories/html-js/"}]}