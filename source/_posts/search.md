---
title: 几种查找的数据结构(二叉搜索树、2-3树及红黑树)
date: 2022-06-12 23:46:38
tags: algorithm
categories: 
- algorithm
- binary search tree
---

现代计算机和网络使我们能够访问海量的信息。高效检索这些信息的能力是处理它们的重要前提.本文主要介绍几种经典的数据结构,及分析其插入和查找效率

<!--more-->
## 链表

下图为一个基于单向链表的添加与查找的轨迹.每次插入一个新元素前先查找是否存在相同的key,不存在则在首部新增一个节点,存在则替换当前节点的值.

{% asset_img WechatIMG167.png '同异步分类' %}

由上图可知,一个链表长度为N插入一个新数据的时间复杂度为 O(1), 即只需在首部插入即可.而查找,需要每个节点依次寻找,最好为1,最差为N.
平均时间复杂度为O(N)

## 有序数组

无序数组与链表类似,查询依次为O(N),添加为O(1);

有序数组的查找分两种: 一种是顺序查找时间复杂度为O(N), 另一种是二分查找时间复杂度是O(logN).添加时间复杂度为O(N), 插入流程如下图:

{% asset_img WechatIMG168.png '同异步分类' %}

## 二叉查找树

以上两种数据结构插入和查找的时间复杂度如下表

| 数据结构  |   查找   |   插入   |
| :----: | :----: | :----:|
| 链表 | O(N) | O(1) |
| 有序数组(顺序查找) | O(N) | O(N) |
| 有序数组(二分查找) | O(log N) | O(N) |

由上图可以看出不论是链表与数组,他的查找和插入顺序都不是很尽如人意, 若构建一个长度为N的数据,两种存储方式:

- 链表: 插入次数 为 N * 1, 查询替换为 N * N, 查询速度太慢
- 数组(二分查找): 插入为 N * N, 查询替换为 NlogN, 插入速度太慢

那有没有一个数据结构能不能兼具查询和插入都足够效率的优点呢.这里我们先介绍下二叉查找树的基本特征.然后再分析

### 二叉查找树定义

一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键.

每一个二叉搜索树的左右子树也都是一个二叉搜索树

二叉搜索树如果用中序遍历一下，就是一个从小到大的递增序列

下图是一颗二叉查找树, 中序遍历得到的结果是 A C E H R S X

{% asset_img WechatIMG170.png '二叉查找树' %}

### 二叉查找树查找

在二叉查找树中分别查找 R 和 T

- R: 先找根节点 **S**, R小于S, 在 S的左子树查找, 左子树根节点 **E**, R大于 E, 则在E的右子树找, 右子树根节点 **R**, 命中.
- T: 先找根节点 **S**, T小于S, 在 S的右子树查找, 左子树根节点 **X**, T小于 X, 则在E的右子树找, 左子树根节点为空, 未命中

{% asset_img WechatIMG171.png '二叉查找树查找' %}

### 二叉查找树插入 

二叉查找树的查找几乎和二分查找的一样简单,而且插入的实现难度和查找差不多,
当要插入的节点的键在二叉查找树查找树命中时,则直接替换命中键的值.未被命中为空节点时,如果被查找的键小于空节点根结点的键，我们会继续在左子树中插入该键，否则在右子树中插入该键。

{% asset_img WechatIMG172.png '二叉查找树插入' %}


### 平衡二叉树的2-3树·概念

什么是平衡二叉树:

- 可以是空树。
- 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

### 分析

使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一棵含有 N 个结点的树是完全平衡的，每条空链接和根结点的距离都为 **logN**。在最坏的情况下，搜索路径上可能有 **N**个结点, 变成了一个链表.如图所示。但在一般情况下树的形状和最好情况更接近。

{% asset_img WechatIMG173.png '二叉查找树的最优和最坏情况' %}

## 2-3树

上面说到,一颗二叉查找树在最差情况下会退化为链表,它的插入和查找的时间复杂度均为**N**,此时的性能是很糟糕的.为了保证二分查找树的平衡性,将运行时间控制在对数级,引入了**2-3树**概念

### 2-3树定义

为了保证查找树的平衡性,我们允许树中一个节点储存多个键来获得更多的灵活性.一个2-3查找树或由以下节点组成:

- 2-节点: 标准的二叉查找树中的节点.含有**一个键**（及其对应的值）和**两条链接**,左链接指向的目标节点中的键都小于该结点，右链接指向的目标节点的键都大于该结点。 

- 3-节点: 含有**两个键**（及其对应的值）和**三条链接**，**左链接**指向的目标节点的键都**小于**该结点，中链接指向的目标节点中的键都位于该结点的两个键之间，右链接指向的目标节点中的键都大于该结点。

**注: 一棵完美平衡的 2-3 查找树中的所有空链接到根结点的距离都应该是相同的。简洁起见，这里我们用 2-3 树指代一棵完美平衡的 2-3 查找树（在其他情况下这个词应该表示一种更一般的结构）**

{% asset_img WechatIMG174.png '2-3树·' %}

### 2-3树的查找

将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中

下图为对H的命中查找及对B的未命中查找:

{% asset_img WechatIMG175.png '2-3树查找' %}

### 2-3树插入

空树的插入很简单,创建一个节点即可.非空树则分四种情况:

- 向2-节点中插入元素；
 
- 向一颗只含有一个3-节点的树中插入元素；
 
- 向一个父节点为2-节点的3-节点中插入元素；
 
- 向一个父节点为3-节点的3-节点中插入元素2-3树

#### 向2-节点中插入元素

如果未命中查找结束于2-节点, 我们只要把这个 2- 结点替换为一个 3- 结点

{% asset_img WechatIMG176.png '向2-节点中插入元素' %}

#### 向一颗只含有一个3-节点的树中插入元素

我们先临时将新键存入该结点中，使之成为一个 4- 结点, 然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树, 中间的节点变成左右节点的父节点. 构成的这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树

{% asset_img WechatIMG177.png '向一棵只含有一个3-结点的树中插入新键' %}

#### 向一个父节点为2-节点的3-节点中插入元素

我们先像刚才一样构造一个临时的 4- 结点并将其分解, 但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中, 父结点是一个 2- 结点（一个键两条链接），
插入之后变为了一个 3- 结点. 这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，
插入后所有的空链接到根结点的距离仍然相同

{% asset_img WechatIMG178.png '向一个父节点为2-节点的3-节点中插入元素' %}

#### 向一个父节点为3-节点的3-节点中插入元素

再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根,然后将它转换为一棵由 3 个 2- 结点组成的 2-3 树

{% asset_img WechatIMG179.png '向一个父节点为3-节点的3-节点中插入元素' %}

分解根节点

{% asset_img WechatIMG180.png '分解根节点' %}

### 2-3树节点关系

{% asset_img WechatIMG181.png '2-3树节点关系' %}

### 2-3树构造轨迹: 即使升序插入也不会退化为链表,如下图所示:

{% asset_img WechatIMG182.png '2-3树构造轨迹' %}

### 性质:

和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的

> **命题 F**在一棵大小为  的 2-3 树中，查找和插入操作访问的结点必然不超过**lgN**

> **证明**。一棵含有 N 个结点的 2-3 树的高度在 **log3 N**（如果树中全是 3- 结点）和 **log2 N**（如果树中全是 2- 结点）之间

## 红黑树二叉搜索树

上文中2-3树可以实现树的**有序性**与**平衡性**,但是要维护两种不同类型的节点(2-节点与**3-节点**),将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢.

### 红黑树二叉搜索树替换2-3树

红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由 2- 结点构成）和一些额外的
信息（替换 3- 结点）来表示 2-3 树.树的链接分为两种: **红链接**将两个 2- 结点
连

{% asset_img WechatIMG183.png '红黑树二叉搜索树替换2-3树' %}

### 红黑树二叉搜索树定义

红黑树是含有红黑链接并满足下列条件的二叉查找树：

- 红链接均为左链接；
- 没有任何一个结点同时和两条红链接相连；
- 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。

满足这样定义的红黑树和相应的 2-3 树是一一对应的

{% asset_img WechatIMG184.png '红黑树和相应的2-3 树' %}

### 红黑树二叉搜索树的插入

每次插入的节点的时候都将节点的颜色初始化为红色

#### 旋转

在我们实现的某些操作中(比如插入)可能会出现红色右链接或者两条连续的红链接,
需要通过**旋转**和**变换颜色**修复,旋转操作会改变红链接的指向, 

#### 左旋转

{% asset_img WechatIMG185.png '红黑树左旋转' %}

#### 右旋转

{% asset_img WechatIMG186.png '红黑树右旋转' %}

无论是rotateRight()或rotateLeft() , 我们总是将其返回值重置父结点（或是根结点),且保留原来父节点的颜色(将 x.color 设为 h.color)

#### 颜色变换

当我们的节点经过左右旋转时,有可能出现左右节点均为红色的场景,此时,我们需要颜色变换.

我们专门用一个方法 **flipColors()** 来转换一个结点的两个红色子结点
的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将**父结点的颜色由黑变红**(相当于父节点上浮,和它的父节点结合成为一个3-节点),这项
操作和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性.

{% asset_img WechatIMG187.png '红黑树颜色变换' %}

### 红黑树的链接向上传递

只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作, 在沿着插入点到根结点的路径向上移动时在所经过
的每个结点中顺序完成以下操作，我们就能完成插入操作：

- 如果右子结点是红色的而左子结点是黑色的，进行左旋转；
- 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；
- 如果左右子结点均为红色，进行颜色转换。

注意,红黑树的根节点为黑色!

### 复合的插入过程

{% asset_img WechatIMG188.png '复合的插入过程' %}

### 完整得建立一颗红黑树

{% asset_img WechatIMG189.png '完整得建立一颗红黑树' %}















